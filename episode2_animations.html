<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Episode 2: The Branching Universe - Manim-Style Animations</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #0a0a0a;
            color: #e0e0e0;
            overflow-x: hidden;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            padding-right: 500px;
        }

        @media (max-width: 1400px) {
            .container {
                padding-right: 20px;
            }
            .code-viewer {
                position: relative;
                right: auto;
                top: auto;
                width: 100%;
                margin: 20px 0;
            }
        }

        h1 {
            text-align: center;
            margin: 40px 0;
            font-size: 2.5em;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .section {
            margin: 60px 0;
            padding: 40px;
            background: rgba(255, 255, 255, 0.03);
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 1s ease;
        }

        .section.active-narration {
            background: rgba(102, 126, 234, 0.08);
            border: 2px solid rgba(102, 126, 234, 0.5);
            box-shadow: 0 8px 40px rgba(102, 126, 234, 0.3);
            transform: scale(1.01);
        }

        .section-title {
            font-size: 1.8em;
            margin-bottom: 30px;
            color: #667eea;
        }

        .animation-canvas {
            width: 100%;
            height: 400px;
            background: #1a1a1a;
            border-radius: 10px;
            position: relative;
            overflow: hidden;
            margin: 20px 0;
            border: 2px solid rgba(102, 126, 234, 0.3);
        }

        .control-panel {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin: 20px 0;
            flex-wrap: wrap;
        }

        .btn {
            padding: 12px 28px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            border-radius: 8px;
            color: white;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.5);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn.secondary {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        }

        .btn.success {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
        }

        .btn.warning {
            background: linear-gradient(135deg, #f5576c 0%, #f093fb 100%);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn.play-all {
            background: linear-gradient(135deg, #50fa7b 0%, #4facfe 100%);
            font-size: 18px;
            padding: 15px 40px;
            box-shadow: 0 6px 25px rgba(80, 250, 123, 0.4);
        }

        .narration-indicator {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(102, 126, 234, 0.95);
            padding: 15px 25px;
            border-radius: 10px;
            font-weight: bold;
            display: none;
            z-index: 2000;
            animation: fadeIn 0.5s;
            box-shadow: 0 4px 20px rgba(102, 126, 234, 0.6);
        }

        .narration-indicator.active {
            display: block;
        }

        .progress-bar {
            position: fixed;
            top: 0;
            left: 0;
            height: 4px;
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            width: 0%;
            transition: width 0.5s ease;
            z-index: 2001;
        }

        .code-viewer {
            position: fixed;
            right: 20px;
            top: 80px;
            width: 450px;
            max-height: calc(100vh - 120px);
            background: rgba(13, 17, 23, 0.98);
            padding: 25px;
            border-radius: 12px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 15px;
            border: 2px solid rgba(102, 126, 234, 0.6);
            box-shadow: 0 10px 50px rgba(0, 0, 0, 0.8);
            opacity: 0;
            transform: translateX(500px);
            transition: all 0.5s ease;
            z-index: 2000;
            overflow-y: auto;
        }

        .code-viewer.active {
            opacity: 1;
            transform: translateX(0);
        }

        .code-viewer-title {
            color: #667eea;
            font-weight: bold;
            margin-bottom: 15px;
            padding-bottom: 12px;
            font-size: 16px;
            text-transform: uppercase;
            letter-spacing: 1px;
            border-bottom: 2px solid rgba(102, 126, 234, 0.3);
        }

        .code-viewer-subtitle {
            color: #f093fb;
            font-size: 13px;
            font-weight: normal;
            margin-top: 8px;
            opacity: 0.9;
        }

        .code-viewer-content {
            color: #e0e0e0;
            line-height: 1.8;
        }

        .code-viewer-content .cmd {
            color: #50fa7b;
            font-weight: bold;
        }

        .code-viewer-content .comment {
            color: #6272a4;
            font-style: italic;
        }

        .code-viewer-content .string {
            color: #f1fa8c;
        }

        .code-viewer-content .keyword {
            color: #c678dd;
            font-weight: bold;
        }

        .code-viewer-content .function {
            color: #61afef;
        }

        .code-viewer-content .separator {
            display: block;
            height: 1px;
            background: linear-gradient(90deg, transparent, rgba(102, 126, 234, 0.3), transparent);
            margin: 20px 0;
        }

        .code-viewer-content .command-block {
            margin-bottom: 25px;
            padding-bottom: 15px;
            border-bottom: 1px solid rgba(102, 126, 234, 0.2);
        }

        .code-viewer-content .command-block:last-child {
            border-bottom: none;
        }

        .typing-cursor {
            display: inline-block;
            width: 10px;
            height: 20px;
            background: #50fa7b;
            margin-left: 3px;
            animation: blink 1s infinite;
            vertical-align: text-bottom;
        }

        @keyframes blink {
            0%, 49% { opacity: 1; }
            50%, 100% { opacity: 0; }
        }



        .description {
            margin: 20px 0;
            padding: 20px;
            background: rgba(102, 126, 234, 0.1);
            border-left: 4px solid #667eea;
            border-radius: 5px;
            line-height: 1.6;
        }

        .code-display {
            background: #0d1117;
            padding: 20px;
            border-radius: 8px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 14px;
            margin: 20px 0;
            border: 1px solid rgba(102, 126, 234, 0.2);
            overflow-x: auto;
        }

        .code-display .keyword { color: #ff79c6; }
        .code-display .function { color: #50fa7b; }
        .code-display .comment { color: #6272a4; }
        .code-display .string { color: #f1fa8c; }
        .code-display .conflict { color: #f5576c; font-weight: bold; }
        .code-display .resolved { color: #4facfe; font-weight: bold; }

        .code-display.typing {
            position: relative;
        }

        .code-display .code-line {
            opacity: 0;
            animation: fadeInLine 0.3s forwards;
        }

        @keyframes fadeInLine {
            to { opacity: 1; }
        }

        /* Node styles for animations */
        .node {
            position: absolute;
            width: 70px;
            height: 70px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            box-shadow: 0 4px 20px rgba(102, 126, 234, 0.5);
            transition: all 1s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            font-size: 14px;
        }

        .node.main {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        .node.feature {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
        }

        .node.merge {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            box-shadow: 0 6px 30px rgba(245, 87, 108, 0.8);
        }

        .node .label {
            font-size: 10px;
            opacity: 0.8;
        }

        .node .value {
            font-size: 16px;
            margin-top: 3px;
        }

        .arrow {
            position: absolute;
            height: 3px;
            background: rgba(255, 255, 255, 0.8);
            transform-origin: left center;
            transition: all 1s ease;
        }

        .arrow::after {
            content: '';
            position: absolute;
            right: -10px;
            top: -5px;
            width: 0;
            height: 0;
            border-left: 12px solid rgba(255, 255, 255, 0.8);
            border-top: 6px solid transparent;
            border-bottom: 6px solid transparent;
        }

        .branch-label {
            position: absolute;
            padding: 5px 12px;
            background: rgba(102, 126, 234, 0.9);
            border-radius: 12px;
            font-size: 12px;
            font-weight: bold;
            color: white;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
            transition: all 0.5s ease;
        }

        .branch-label.feature {
            background: rgba(79, 172, 254, 0.9);
        }

        .highlight {
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); box-shadow: 0 4px 20px rgba(102, 126, 234, 0.5); }
            50% { transform: scale(1.1); box-shadow: 0 6px 30px rgba(102, 126, 234, 0.8); }
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .stats-panel {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin: 30px 0;
        }

        .stat-card {
            background: rgba(102, 126, 234, 0.1);
            padding: 20px;
            border-radius: 10px;
            border: 1px solid rgba(102, 126, 234, 0.3);
            text-align: center;
        }

        .stat-value {
            font-size: 2em;
            font-weight: bold;
            color: #667eea;
            margin: 10px 0;
        }

        .stat-label {
            font-size: 0.9em;
            opacity: 0.7;
        }

        .scale-break {
            background: rgba(245, 87, 108, 0.1);
            border-left: 4px solid #f5576c;
            padding: 20px;
            margin: 20px 0;
            border-radius: 5px;
        }

        .scale-break-title {
            color: #f5576c;
            font-weight: bold;
            margin-bottom: 10px;
            font-size: 1.2em;
        }

        .comparison {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 30px 0;
            width: 100%;
        }

        .comparison-side {
            padding: 20px;
            border-radius: 10px;
        }

        .comparison-side.naive {
            background: rgba(245, 87, 108, 0.1);
            border: 2px solid rgba(245, 87, 108, 0.3);
        }

        .comparison-side.production {
            background: rgba(79, 172, 254, 0.1);
            border: 2px solid rgba(79, 172, 254, 0.3);
        }

        .comparison-title {
            font-size: 1.3em;
            font-weight: bold;
            margin-bottom: 15px;
        }

        .comparison-side.naive .comparison-title {
            color: #f5576c;
        }

        .comparison-side.production .comparison-title {
            color: #4facfe;
        }

        .conflict-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            animation: fadeIn 0.5s;
        }

        .conflict-panel {
            background: #1a1a1a;
            border-radius: 15px;
            padding: 40px;
            max-width: 1000px;
            width: 90%;
            border: 2px solid #f5576c;
            box-shadow: 0 10px 50px rgba(245, 87, 108, 0.5);
        }

        .conflict-title {
            font-size: 2em;
            color: #f5576c;
            margin-bottom: 20px;
            text-align: center;
        }

        .conflict-code-panels {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 30px 0;
        }

        .conflict-code-panel {
            background: #0d1117;
            padding: 20px;
            border-radius: 8px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 13px;
        }

        .conflict-code-panel.main {
            border: 2px solid #667eea;
        }

        .conflict-code-panel.feature {
            border: 2px solid #4facfe;
        }

        .conflict-header {
            font-weight: bold;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .conflict-code-panel.main .conflict-header {
            color: #667eea;
        }

        .conflict-code-panel.feature .conflict-header {
            color: #4facfe;
        }

        @media (max-width: 768px) {
            .comparison, .conflict-code-panels {
                grid-template-columns: 1fr;
            }
            
            h1 {
                font-size: 1.8em;
            }
            
            .animation-canvas {
                height: 300px;
            }
        }
    </style>
</head>
<body>
    <div class="progress-bar" id="progress-bar"></div>
    <div class="narration-indicator" id="narration-indicator">üé¨ Act 1: Branch Creation</div>
    <div class="code-viewer" id="code-viewer">
        <div class="code-viewer-title" id="code-viewer-title">
            üìù Live Commands
            <div class="code-viewer-subtitle" id="code-viewer-subtitle">Watch what's happening...</div>
        </div>
        <div class="code-viewer-content" id="code-viewer-content"></div>
    </div>
    
    <div class="container">
        <h1>üå≥ Episode 2: The Branching Universe</h1>
        <p style="text-align: center; font-size: 1.2em; opacity: 0.8; margin-bottom: 20px;">
            How Git Handles Divergence, Merges, and the DAG
        </p>
        
        <div class="control-panel" style="margin-bottom: 40px;">
            <button class="btn play-all" onclick="playbackController.playAll()">‚ñ∂ Play All (Voice-Over Mode)</button>
            <button class="btn secondary" onclick="playbackController.pause()">‚è∏ Pause</button>
            <button class="btn secondary" onclick="playbackController.reset()">‚Ü∫ Reset All</button>
        </div>

        <!-- Intro: LeetCode Foundation -->
        <div class="section" style="background: rgba(102, 126, 234, 0.05);">
            <h2 class="section-title">üéØ The Foundation: LeetCode #160</h2>
            <div class="description" style="font-size: 1.05em; line-height: 1.8;">
                <strong>Intersection of Two Linked Lists ‚Üí Git Merge Base</strong><br><br>
                Before diving into Git's branching, let's understand the core algorithm.<br>
                Finding a merge base is identical to finding where two linked lists intersect.
            </div>

            <div class="code-display">
<span class="comment"># LeetCode #160: Brute Force (What we write first)</span>
<span class="keyword">def</span> <span class="function">getIntersectionNode_bruteforce</span>(headA, headB):
    <span class="string">"""O(n¬≤) - Check every pair of nodes."""</span>
    currentA = headA
    <span class="keyword">while</span> currentA:
        currentB = headB
        <span class="keyword">while</span> currentB:
            <span class="keyword">if</span> currentA <span class="keyword">is</span> currentB:  <span class="comment"># Identity check</span>
                <span class="keyword">return</span> currentA
            currentB = currentB.<span class="keyword">next</span>
        currentA = currentA.<span class="keyword">next</span>
    <span class="keyword">return</span> <span class="keyword">None</span>

<span class="comment"># Problem: 100k nodes each = 10 billion comparisons!</span>
<span class="comment"># At 10ns per comparison = 100 seconds. Unacceptable.</span>
            </div>

            <div class="code-display" style="margin-top: 15px;">
<span class="comment"># LeetCode #160: Optimized (The elegant solution)</span>
<span class="keyword">def</span> <span class="function">getIntersectionNode_aligned</span>(headA, headB):
    <span class="string">"""O(n) time, O(1) space - alignment trick."""</span>
    <span class="comment"># Step 1: Measure lengths</span>
    lenA = lenB = <span class="number">0</span>
    currA, currB = headA, headB
    
    <span class="keyword">while</span> currA:
        lenA += <span class="number">1</span>
        currA = currA.<span class="keyword">next</span>
    <span class="keyword">while</span> currB:
        lenB += <span class="number">1</span>
        currB = currB.<span class="keyword">next</span>
    
    <span class="comment"># Step 2: Align starting points (skip extra nodes)</span>
    currA, currB = headA, headB
    <span class="keyword">if</span> lenA > lenB:
        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="function">range</span>(lenA - lenB):
            currA = currA.<span class="keyword">next</span>
    <span class="keyword">else</span>:
        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="function">range</span>(lenB - lenA):
            currB = currB.<span class="keyword">next</span>
    
    <span class="comment"># Step 3: Walk together until intersection</span>
    <span class="keyword">while</span> currA <span class="keyword">and</span> currB:
        <span class="keyword">if</span> currA <span class="keyword">is</span> currB:
            <span class="keyword">return</span> currA
        currA = currA.<span class="keyword">next</span>
        currB = currB.<span class="keyword">next</span>
    
    <span class="keyword">return</span> <span class="keyword">None</span>

<span class="comment"># Insight: If lists intersect, they share a tail.</span>
<span class="comment"># By aligning, both pointers become equidistant from intersection.</span>
<span class="comment"># This is the foundation Git builds upon!</span>
            </div>

            <div class="comparison" style="margin-top: 20px;">
                <div class="comparison-side naive">
                    <div class="comparison-title">‚ùå Brute Force O(n¬≤)</div>
                    <ul style="line-height: 2;">
                        <li>Check every pair</li>
                        <li>100k nodes = 10B ops</li>
                        <li>100 seconds</li>
                        <li>Unacceptable at scale</li>
                    </ul>
                </div>
                <div class="comparison-side production">
                    <div class="comparison-title">‚úì Aligned O(n)</div>
                    <ul style="line-height: 2;">
                        <li>Single pass each list</li>
                        <li>100k nodes = 200k ops</li>
                        <li>2 milliseconds</li>
                        <li>50,000x faster!</li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Animation 1: Branch Creation -->
        <div class="section" id="section-1" data-act="Act 1: Branch Creation">
            <h2 class="section-title">Act 1: Branch Creation ‚Äì Divergence from Main</h2>
            <div class="description">
                <strong>The Foundation of Parallel Development</strong><br>
                Branches allow teams to work on features independently without blocking each other.
                Watch how a new branch splits off from main, creating a parallel timeline.
            </div>

            <div class="animation-canvas" id="canvas1"></div>

            <div class="code-display">
<span class="comment"># Creating a new branch</span>
<span class="keyword">git</span> checkout -b feature/new-algorithm

<span class="comment"># Make changes on feature branch</span>
<span class="keyword">git</span> add optimized_search.py
<span class="keyword">git</span> commit -m <span class="string">"Implement binary search optimization"</span>

<span class="comment"># Meanwhile, main branch continues independently</span>
<span class="keyword">git</span> checkout main
<span class="keyword">git</span> commit -m <span class="string">"Fix bug in production"</span>
            </div>

            <div class="stats-panel">
                <div class="stat-card">
                    <div class="stat-label">Main Commits</div>
                    <div class="stat-value" id="main-commits">0</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Feature Commits</div>
                    <div class="stat-value" id="feature-commits">0</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Branches</div>
                    <div class="stat-value" id="branch-count">1</div>
                </div>
            </div>
        </div>

        <!-- Animation 2: Merge -->
        <div class="section" id="section-2" data-act="Act 2: Merge Commits">
            <h2 class="section-title">Act 2: Merge ‚Äì Bringing Branches Together</h2>
            <div class="description">
                <strong>The Merge Commit</strong><br>
                When feature work is complete, it's merged back into main.
                A merge commit has TWO parents, preserving the full history of both branches.
            </div>

            <div class="animation-canvas" id="canvas2"></div>

            <div class="comparison">
                <div class="comparison-side naive">
                    <div class="comparison-title">‚ùå Naive Approach: Rewrite History</div>
                    <ul style="line-height: 2;">
                        <li>Copy commits from feature to main</li>
                        <li>Lose branch context</li>
                        <li>No way to trace where changes came from</li>
                        <li>Breaks traceability</li>
                    </ul>
                </div>
                <div class="comparison-side production">
                    <div class="comparison-title">‚úì Production: Merge Commit</div>
                    <ul style="line-height: 2;">
                        <li>Create commit with 2 parents</li>
                        <li>Preserve full history</li>
                        <li>Track origin of all changes</li>
                        <li>Enable rollback and analysis</li>
                    </ul>
                </div>
            </div>

            <div class="code-display" style="margin-top: 20px;">
<span class="comment"># Python Implementation: MergeBaseStorageAware class</span>
<span class="comment"># This class finds the common ancestor (merge base) of two commits</span>
<span class="comment"># by traversing the commit graph using storage-aware lookups</span>

<span class="keyword">def</span> <span class="function">find_merge_base_storage_aware</span>(sha1, sha2, git_storage):
    <span class="string">"""Find merge base using LeetCode #160 pattern (Intersection of Two Linked Lists)
    
    Args:
        sha1: First commit SHA-1
        sha2: Second commit SHA-1
        git_storage: GitStorage instance for parent lookups
    
    Returns:
        SHA-1 of the merge base (common ancestor)
    """</span>
    ancestors = <span class="function">set</span>()
    
    <span class="comment"># Traverse first commit's ancestry</span>
    <span class="keyword">while</span> sha1:
        ancestors.<span class="function">add</span>(sha1)
        sha1 = git_storage.<span class="function">get_parent</span>(sha1)
    
    <span class="comment"># Traverse second commit until we find intersection</span>
    <span class="keyword">while</span> sha2:
        <span class="keyword">if</span> sha2 <span class="keyword">in</span> ancestors:
            <span class="keyword">return</span> sha2  <span class="comment"># Found merge base!</span>
        sha2 = git_storage.<span class="function">get_parent</span>(sha2)
    
    <span class="keyword">return</span> <span class="keyword">None</span>  <span class="comment"># No common ancestor</span>
            </div>

            <div class="code-display">
<span class="comment"># Merge feature branch into main</span>
<span class="keyword">git</span> checkout main
<span class="keyword">git</span> merge feature/new-algorithm

<span class="comment"># Creates a merge commit with 2 parents:</span>
<span class="comment"># parent1: last commit on main</span>
<span class="comment"># parent2: last commit on feature branch</span>

<span class="keyword">git</span> log --graph --oneline
<span class="comment"># Shows the merge as a diamond shape in the history</span>
            </div>

            <div class="stats-panel">
                <div class="stat-card">
                    <div class="stat-label">Merge Commits</div>
                    <div class="stat-value" id="merge-count">0</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Parents</div>
                    <div class="stat-value">2</div>
                </div>
            </div>

            <div class="scale-break" style="margin-top: 30px;">
                <div class="scale-break-title">‚ö° Why Storage Awareness Matters</div>
                In LeetCode, <code>.next</code> is instant (in-memory pointer).<br>
                In Git, getting a parent commit involves reading from disk!
            </div>

            <div class="code-display" style="margin-top: 15px;">
<span class="comment"># Git Storage Hierarchy (from fastest to slowest)</span>

<span class="keyword">class</span> <span class="function">GitStorageSystem</span>:
    <span class="string">"""Multi-layer storage with different access costs."""</span>
    
    <span class="keyword">def</span> <span class="function">__init__</span>(<span class="keyword">self</span>):
        <span class="keyword">self</span>.memory_cache = {}       <span class="comment"># ~10ns per access</span>
        <span class="keyword">self</span>.commit_graph = <span class="keyword">None</span>    <span class="comment"># ~100ns (memory-mapped)</span>
        <span class="keyword">self</span>.packfiles = []          <span class="comment"># ~1ms (disk + decompress)</span>
        <span class="keyword">self</span>.loose_objects = {}      <span class="comment"># ~10ms (filesystem lookup)</span>
    
    <span class="keyword">def</span> <span class="function">get_parent</span>(<span class="keyword">self</span>, sha):
        <span class="string">"""Get parent SHA - cost varies by storage layer!"""</span>
        <span class="comment"># Try cache first (10ns)</span>
        <span class="keyword">if</span> sha <span class="keyword">in</span> <span class="keyword">self</span>.memory_cache:
            <span class="keyword">return</span> <span class="keyword">self</span>.memory_cache[sha].parent
        
        <span class="comment"># Try commit-graph (100ns)</span>
        <span class="keyword">if</span> <span class="keyword">self</span>.commit_graph:
            commit = <span class="keyword">self</span>.commit_graph.<span class="function">get</span>(sha)
            <span class="keyword">if</span> commit:
                <span class="keyword">return</span> commit.parent
        
        <span class="comment"># Try packfiles (1ms) - requires decompression</span>
        <span class="keyword">for</span> pack <span class="keyword">in</span> <span class="keyword">self</span>.packfiles:
            <span class="keyword">if</span> pack.<span class="function">contains</span>(sha):
                commit = pack.<span class="function">read_with_deltas</span>(sha)
                <span class="keyword">return</span> commit.parent
        
        <span class="comment"># Try loose objects (10ms) - slowest</span>
        path = <span class="function">f</span><span class="string">".git/objects/{sha[:2]}/{sha[2:]}"</span>
        <span class="keyword">return</span> <span class="keyword">self</span>.<span class="function">read_from_disk</span>(path).parent

<span class="comment"># The problem: Our O(n) algorithm becomes O(n √ó disk_seeks)!</span>
<span class="comment"># 100k commits √ó 1ms per seek = 100 seconds vs 2ms in memory</span>
            </div>

            <div class="comparison" style="margin-top: 20px;">
                <div class="comparison-side naive">
                    <div class="comparison-title">‚ùå Naive Disk Access</div>
                    <ul style="line-height: 2;">
                        <li>Read commits one at a time</li>
                        <li>100k disk seeks</li>
                        <li>1ms each = 100 seconds</li>
                        <li>50,000x slower than memory!</li>
                    </ul>
                </div>
                <div class="comparison-side production">
                    <div class="comparison-title">‚úì Batched + Cached</div>
                    <ul style="line-height: 2;">
                        <li>Batch 100 reads together</li>
                        <li>1,000 batched operations</li>
                        <li>Cache hot commits in RAM</li>
                        <li>Result: <strong>&lt;1ms</strong></li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Animation 3: Conflict -->
        <div class="section" id="section-3" data-act="Act 3: Merge Conflicts">
            <h2 class="section-title">Act 3: Scale Break #1 ‚Äì Merge Conflicts</h2>
            <div class="scale-break">
                <div class="scale-break-title">‚ö†Ô∏è The Problem</div>
                When both branches modify the same lines, Git can't automatically merge.
                Without conflict resolution, parallel development would be impossible.
            </div>

            <div class="description">
                <strong>The Conflict Scenario</strong><br>
                Main and feature both change the same function. Git detects the conflict and stops,
                requiring manual resolution before the merge can complete.
            </div>

            <div class="animation-canvas" id="canvas3"></div>

            <div class="stats-panel">
                <div class="stat-card">
                    <div class="stat-label">Conflicts Detected</div>
                    <div class="stat-value" id="conflict-count">0</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Conflicts Resolved</div>
                    <div class="stat-value" id="resolved-count">0</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Files Affected</div>
                    <div class="stat-value" id="files-affected">0</div>
                </div>
            </div>

            <div class="code-display" style="margin-top: 20px;">
<span class="comment"># Python Implementation: MergeBaseWithValidation class</span>
<span class="comment"># Validates merge operations and detects conflicts using three-way merge</span>

<span class="keyword">def</span> <span class="function">find_merge_base_with_validation</span>(sha1, sha2, git_storage, strict=<span class="keyword">True</span>):
    <span class="string">"""Find merge base with validation checks.
    
    This class extends basic merge-base to add:
    - Input validation (commits exist?)
    - Corruption detection (cycle checks)
    - Error handling with detailed messages
    - Strict mode for production use
    """</span>
    <span class="keyword">if</span> strict:
        <span class="comment"># Validate inputs exist in storage</span>
        <span class="keyword">if</span> <span class="keyword">not</span> git_storage.<span class="function">commit_exists</span>(sha1):
            <span class="keyword">raise</span> <span class="function">ValueError</span>(<span class="string">f"Commit {sha1} not found"</span>)
        <span class="keyword">if</span> <span class="keyword">not</span> git_storage.<span class="function">commit_exists</span>(sha2):
            <span class="keyword">raise</span> <span class="function">ValueError</span>(<span class="string">f"Commit {sha2} not found"</span>)
    
    <span class="comment"># Find merge base using storage-aware algorithm</span>
    base = <span class="function">find_merge_base_storage_aware</span>(sha1, sha2, git_storage)
    
    <span class="keyword">if</span> base <span class="keyword">is</span> <span class="keyword">None</span> <span class="keyword">and</span> strict:
        <span class="keyword">raise</span> <span class="function">ValueError</span>(<span class="string">"No common ancestor found"</span>)
    
    <span class="keyword">return</span> base
            </div>

            <div class="scale-break" style="margin-top: 30px;">
                <div class="scale-break-title">üîç Three-Way Merge Algorithm</div>
                Why does Git need the merge base? To perform intelligent three-way merging!
            </div>

            <div class="code-display" style="margin-top: 15px;">
<span class="comment"># Three-Way Merge: Base + Ours + Theirs = Result</span>

<span class="keyword">def</span> <span class="function">three_way_merge</span>(base, ours, theirs):
    <span class="string">"""Smart merge using common ancestor (base)."""</span>
    
    <span class="comment"># Example: Merging file content</span>
    <span class="comment"># Base:   "hello world"</span>
    <span class="comment"># Ours:   "hello world!"    (added !)</span>
    <span class="comment"># Theirs: "hello beautiful world"  (added beautiful)</span>
    
    result = []
    <span class="keyword">for</span> line <span class="keyword">in</span> base.<span class="function">split</span>(<span class="string">'\n'</span>):
        ours_change = <span class="function">get_change</span>(base, ours, line)
        theirs_change = <span class="function">get_change</span>(base, theirs, line)
        
        <span class="keyword">if</span> ours_change == theirs_change:
            <span class="comment"># Both made same change (or no change)</span>
            result.<span class="function">append</span>(ours_change)
        
        <span class="keyword">elif</span> ours_change == line:
            <span class="comment"># We didn't change, use their change</span>
            result.<span class="function">append</span>(theirs_change)
        
        <span class="keyword">elif</span> theirs_change == line:
            <span class="comment"># They didn't change, use our change</span>
            result.<span class="function">append</span>(ours_change)
        
        <span class="keyword">else</span>:
            <span class="comment"># CONFLICT: Both changed the same line!</span>
            result.<span class="function">append</span>(<span class="function">create_conflict_marker</span>(ours_change, theirs_change))
    
    <span class="keyword">return</span> <span class="string">'\n'</span>.<span class="function">join</span>(result)

<span class="comment"># Result: "hello beautiful world!" (both changes merged!)</span>
<span class="comment"># Without base, we can't tell if difference is change or deletion</span>
            </div>

            <div class="comparison" style="margin-top: 20px;">
                <div class="comparison-side naive">
                    <div class="comparison-title">‚ùå Without Merge Base</div>
                    <ul style="line-height: 2;">
                        <li>Can't distinguish change vs deletion</li>
                        <li>Every difference = potential conflict</li>
                        <li>Manual review of everything</li>
                        <li>Parallel work impossible</li>
                    </ul>
                </div>
                <div class="comparison-side production">
                    <div class="comparison-title">‚úì With Merge Base</div>
                    <ul style="line-height: 2;">
                        <li>Clear: what changed since base</li>
                        <li>Auto-merge non-conflicting changes</li>
                        <li>Only flag true conflicts</li>
                        <li>Enables team collaboration</li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Animation 4: The DAG -->
        <div class="section" id="section-4" data-act="Act 4: The DAG">
            <h2 class="section-title">Act 4: The Commit Graph ‚Äì Visualizing the DAG</h2>
            <div class="description">
                <strong>Directed Acyclic Graph (DAG)</strong><br>
                Git's commit history is not a linear chain‚Äîit's a DAG.
                Each commit points to its parent(s), forming a graph that can branch and merge.
                Watch as we build a complex history with multiple branches and merges.
            </div>

            <div class="animation-canvas" id="canvas4" style="height: 500px;"></div>

            <div class="comparison">
                <div class="comparison-side naive">
                    <div class="comparison-title">‚ùå Linear History</div>
                    <ul style="line-height: 2;">
                        <li>Single timeline</li>
                        <li>No parallel work</li>
                        <li>Developers block each other</li>
                        <li>No experimentation branches</li>
                    </ul>
                </div>
                <div class="comparison-side production">
                    <div class="comparison-title">‚úì DAG (Git)</div>
                    <ul style="line-height: 2;">
                        <li>Multiple parallel branches</li>
                        <li>Merge commits join histories</li>
                        <li>Non-blocking collaboration</li>
                        <li>Full traceability</li>
                    </ul>
                </div>
            </div>

            <div class="code-display">
<span class="keyword">class</span> <span class="function">CommitDAG</span>:
    <span class="keyword">def</span> <span class="function">__init__</span>(self):
        self.commits = {}  <span class="comment"># hash -> Commit object</span>
        self.branches = {}  <span class="comment"># name -> commit hash</span>
    
    <span class="keyword">def</span> <span class="function">commit</span>(self, parents, message):
        <span class="comment"># Commit can have multiple parents (merge)</span>
        commit = Commit(parents, message)
        self.commits[commit.hash] = commit
        <span class="keyword">return</span> commit.hash
    
    <span class="keyword">def</span> <span class="function">merge</span>(self, branch1, branch2):
        <span class="comment"># Create merge commit with 2 parents</span>
        parent1 = self.branches[branch1]
        parent2 = self.branches[branch2]
        <span class="keyword">return</span> self.commit([parent1, parent2], <span class="string">"Merge"</span>)

<span class="comment"># Git's DAG enables parallel development at massive scale</span>
<span class="comment"># Linux kernel: 1M+ commits, 20K+ contributors, 0 blocking</span>
            </div>

            <div class="code-display" style="margin-top: 20px;">
<span class="comment"># Python Implementation: MergeBaseService class</span>
<span class="comment"># Production-grade service with authentication, caching, metrics, and observability</span>

<span class="keyword">class</span> <span class="function">MergeBaseService</span>:
    <span class="string">"""Enterprise-grade merge base service.
    
    This class wraps the core algorithm with production concerns:
    - User authentication and authorization
    - Repository-level isolation and multi-tenancy
    - Caching for performance (avoid recomputing)
    - Metrics and observability (track usage, errors)
    - Handles complex multi-parent DAGs
    - Distributed systems support
    """</span>
    
    <span class="keyword">def</span> <span class="function">__init__</span>(<span class="keyword">self</span>, cache, metrics, storage_factory):
        <span class="keyword">self</span>.cache = cache              <span class="comment"># Redis/Memcached</span>
        <span class="keyword">self</span>.metrics = metrics          <span class="comment"># Prometheus/Datadog</span>
        <span class="keyword">self</span>.storage_factory = storage_factory
    
    <span class="keyword">def</span> <span class="function">find_merge_base</span>(<span class="keyword">self</span>, repo_id, sha1, sha2, user_context=<span class="keyword">None</span>):
        <span class="comment"># 1. Authenticate and authorize user</span>
        <span class="keyword">if</span> user_context:
            <span class="keyword">self</span>.<span class="function">_check_permissions</span>(user_context, repo_id)
        
        <span class="comment"># 2. Check cache (avoid expensive computation)</span>
        cache_key = <span class="function">f</span><span class="string">"{repo_id}:{sha1}:{sha2}"</span>
        <span class="keyword">if</span> cached := <span class="keyword">self</span>.cache.<span class="function">get</span>(cache_key):
            <span class="keyword">self</span>.metrics.<span class="function">increment</span>(<span class="string">"merge_base_cache_hit"</span>)
            <span class="keyword">return</span> cached
        
        <span class="comment"># 3. Get storage backend for this specific repo</span>
        storage = <span class="keyword">self</span>.storage_factory.<span class="function">get_storage</span>(repo_id)
        
        <span class="comment"># 4. Find merge base with full validation</span>
        <span class="keyword">try</span>:
            result = <span class="function">find_merge_base_with_validation</span>(
                sha1, sha2, storage, strict=<span class="keyword">True</span>
            )
        <span class="keyword">except</span> <span class="function">Exception</span> <span class="keyword">as</span> e:
            <span class="keyword">self</span>.metrics.<span class="function">increment</span>(<span class="string">"merge_base_errors"</span>)
            <span class="keyword">raise</span>
        
        <span class="comment"># 5. Cache result and track success</span>
        <span class="keyword">self</span>.cache.<span class="function">set</span>(cache_key, result, ttl=<span class="number">3600</span>)  <span class="comment"># 1 hour</span>
        <span class="keyword">self</span>.metrics.<span class="function">increment</span>(<span class="string">"merge_base_success"</span>)
        <span class="keyword">return</span> result
            </div>

            <div class="stats-panel">
                <div class="stat-card">
                    <div class="stat-label">Total Commits</div>
                    <div class="stat-value" id="dag-commits">0</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Merge Points</div>
                    <div class="stat-value" id="dag-merges">0</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Active Branches</div>
                    <div class="stat-value" id="dag-branches">0</div>
                </div>
            </div>
        </div>

        <!-- Performance Benchmarks -->
        <div class="section" style="background: rgba(102, 126, 234, 0.05);">
            <h2 class="section-title">üìä Performance: From Theory to Production</h2>
            <div class="description" style="font-size: 1.05em; line-height: 1.8;">
                <strong>Benchmark Scenario</strong>: 100,000 commit repository, branches diverged 50,000 commits ago
            </div>

            <table style="width: 100%; margin: 30px 0; border-collapse: collapse; font-family: 'Consolas', monospace;">
                <thead>
                    <tr style="background: rgba(102, 126, 234, 0.3); border-bottom: 2px solid #667eea;">
                        <th style="padding: 15px; text-align: left; font-size: 1.1em; color: #e0e0e0; font-weight: bold;">Approach</th>
                        <th style="padding: 15px; text-align: center; font-size: 1.1em; color: #e0e0e0; font-weight: bold;">Time Complexity</th>
                        <th style="padding: 15px; text-align: center; font-size: 1.1em; color: #e0e0e0; font-weight: bold;">Actual Time</th>
                        <th style="padding: 15px; text-align: center; font-size: 1.1em; color: #e0e0e0; font-weight: bold;">RAM Usage</th>
                        <th style="padding: 15px; text-align: center; font-size: 1.1em; color: #e0e0e0; font-weight: bold;">Disk I/O</th>
                    </tr>
                </thead>
                <tbody>
                    <tr style="border-bottom: 1px solid rgba(102, 126, 234, 0.2);">
                        <td style="padding: 12px;"><strong>Naive O(n¬≤)</strong><br><span style="opacity: 0.7; font-size: 0.9em;">Brute force comparison</span></td>
                        <td style="padding: 12px; text-align: center;"><code>O(n¬≤)</code></td>
                        <td style="padding: 12px; text-align: center; color: #f5576c; font-weight: bold;">50 seconds</td>
                        <td style="padding: 12px; text-align: center;">~100 MB</td>
                        <td style="padding: 12px; text-align: center;">None (all RAM)</td>
                    </tr>
                    <tr style="border-bottom: 1px solid rgba(102, 126, 234, 0.2);">
                        <td style="padding: 12px;"><strong>Basic O(n)</strong><br><span style="opacity: 0.7; font-size: 0.9em;">Aligned walk, naive disk</span></td>
                        <td style="padding: 12px; text-align: center;"><code>O(n)</code></td>
                        <td style="padding: 12px; text-align: center; color: #f5576c; font-weight: bold;">150 seconds</td>
                        <td style="padding: 12px; text-align: center;">Minimal</td>
                        <td style="padding: 12px; text-align: center;">150k seeks</td>
                    </tr>
                    <tr style="border-bottom: 1px solid rgba(102, 126, 234, 0.2);">
                        <td style="padding: 12px;"><strong>Batched BFS</strong><br><span style="opacity: 0.7; font-size: 0.9em;">Storage-aware batching</span></td>
                        <td style="padding: 12px; text-align: center;"><code>O(n)</code></td>
                        <td style="padding: 12px; text-align: center; color: #f5d76c; font-weight: bold;">10 seconds</td>
                        <td style="padding: 12px; text-align: center;">~10 MB cache</td>
                        <td style="padding: 12px; text-align: center;">1k batches</td>
                    </tr>
                    <tr style="background: rgba(102, 234, 126, 0.1);">
                        <td style="padding: 12px;"><strong>Production System</strong><br><span style="opacity: 0.7; font-size: 0.9em;">Commit-graph + cache</span></td>
                        <td style="padding: 12px; text-align: center;"><code>O(log n)</code></td>
                        <td style="padding: 12px; text-align: center; color: #66ea67; font-weight: bold; font-size: 1.2em;">&lt;1 ms</td>
                        <td style="padding: 12px; text-align: center;">~50 MB mmap</td>
                        <td style="padding: 12px; text-align: center;">None (mmap)</td>
                    </tr>
                </tbody>
            </table>

            <div class="code-display" style="margin-top: 20px;">
<span class="comment"># Key Performance Insights:</span>

<span class="comment"># 1. Algorithm matters: O(n¬≤) ‚Üí O(n) = 50,000x faster</span>
<span class="comment">#    But not enough for production!</span>

<span class="comment"># 2. Storage awareness: Disk seeks dominate</span>
<span class="comment">#    O(n) with disk seeks SLOWER than O(n¬≤) in RAM!</span>
<span class="comment">#    150 seconds vs 50 seconds</span>

<span class="comment"># 3. Batching reduces seeks: 100x improvement</span>
<span class="comment">#    150k seeks ‚Üí 1k batches = 150 seconds ‚Üí 10 seconds</span>

<span class="comment"># 4. Precomputed structures: Final 10,000x leap</span>
<span class="comment">#    Commit-graph + memory-mapping = <1ms</span>
<span class="comment">#    Total improvement: 50,000,000x over naive!</span>

<span class="comment"># Production = Layered Optimizations:</span>
<span class="comment"># - Algorithm (O(n¬≤) ‚Üí O(n))</span>
<span class="comment"># - Storage (batching, compression)</span>
<span class="comment"># - Caching (hot commits in RAM)</span>
<span class="comment"># - Precomputation (commit-graph)</span>
<span class="comment"># - Approximation (fallbacks when exact is too slow)</span>
            </div>

            <div class="description" style="margin-top: 30px; font-size: 1.1em; line-height: 1.8; padding: 20px; background: rgba(102, 126, 234, 0.1); border-radius: 10px;">
                <strong>üéì The Staff Engineer Lesson:</strong><br><br>
                Knowing the O(n) algorithm gets you through LeetCode.<br>
                Understanding storage, caching, and concurrency gets you to production.<br><br>
                <strong>The same algorithm performs 50,000,000x differently</strong> depending on how it's deployed.
            </div>
        </div>

        <!-- Final Summary -->
        <div class="section" id="section-5" data-act="Final Lesson">
            <h2 class="section-title">The Staff Engineer Lesson</h2>
            <div class="description" style="font-size: 1.1em; line-height: 1.8;">
                <strong>Junior engineer:</strong> "I'll work on main and push when done."<br>
                <strong>Senior engineer:</strong> "I'll create a feature branch and merge when ready."<br>
                <strong>Staff engineer:</strong> "I'll design a branching strategy that scales to 10,000 developers."<br><br>
                
                The DAG model is Git's superpower:
                <ul style="margin-top: 15px; margin-left: 30px;">
                    <li><strong>Branching</strong> - Zero-cost parallel development</li>
                    <li><strong>Merging</strong> - Preserve full history with merge commits</li>
                    <li><strong>Conflicts</strong> - Detect and resolve overlapping changes</li>
                    <li><strong>DAG</strong> - Scale to millions of commits without blocking</li>
                </ul>
                <br>
                This is why Git won. Linear history doesn't scale.<br>
                The DAG model enables 100M developers to collaborate without chaos.
            </div>
        </div>
    </div>

    <!-- Conflict Resolution Overlay -->
    <div class="conflict-overlay" id="conflict-overlay">
        <div class="conflict-panel">
            <div class="conflict-title">‚ö†Ô∏è MERGE CONFLICT DETECTED</div>
            <p style="text-align: center; margin-bottom: 20px; opacity: 0.8;">
                Both branches modified <code>search_algorithm.py</code>. Manual resolution required.
            </p>
            
            <div class="conflict-code-panels">
                <div class="conflict-code-panel main">
                    <div class="conflict-header">üìò MAIN BRANCH</div>
                    <pre style="color: #e0e0e0; margin: 0;">def search(arr, target):
    <span style="color: #6272a4;"># Original linear search</span>
    <span style="color: #ff79c6;">for</span> i <span style="color: #ff79c6;">in</span> range(len(arr)):
        <span style="color: #ff79c6;">if</span> arr[i] == target:
            <span style="color: #ff79c6;">return</span> i
    <span style="color: #ff79c6;">return</span> -<span style="color: #bd93f9;">1</span></pre>
                </div>
                
                <div class="conflict-code-panel feature">
                    <div class="conflict-header">üîµ FEATURE BRANCH</div>
                    <pre style="color: #e0e0e0; margin: 0;">def search(arr, target):
    <span style="color: #6272a4;"># Optimized binary search</span>
    left, right = <span style="color: #bd93f9;">0</span>, len(arr) - <span style="color: #bd93f9;">1</span>
    <span style="color: #ff79c6;">while</span> left <= right:
        mid = (left + right) // <span style="color: #bd93f9;">2</span>
        <span style="color: #ff79c6;">if</span> arr[mid] == target:
            <span style="color: #ff79c6;">return</span> mid
        <span style="color: #ff79c6;">elif</span> arr[mid] < target:
            left = mid + <span style="color: #bd93f9;">1</span>
        <span style="color: #ff79c6;">else</span>:
            right = mid - <span style="color: #bd93f9;">1</span>
    <span style="color: #ff79c6;">return</span> -<span style="color: #bd93f9;">1</span></pre>
                </div>
            </div>

            <div style="text-align: center; margin-top: 30px;">
                <button class="btn success" onclick="conflictAnimation.acceptResolution()">
                    Accept Feature Branch (Binary Search)
                </button>
                <button class="btn secondary" onclick="conflictAnimation.closeOverlay()" style="margin-left: 15px;">
                    Cancel
                </button>
            </div>
        </div>
    </div>

    <script>
        // Animation 1: Branch Creation
        class BranchAnimation {
            constructor(canvasId) {
                this.canvas = document.getElementById(canvasId);
                this.mainCommits = [];
                this.featureCommits = [];
                this.branchCreated = false;
                this.commitCounter = 0;
            }

            addCommitMain() {
                this.commitCounter++;
                const commit = {
                    id: this.commitCounter,
                    branch: 'main',
                    x: 100 + (this.mainCommits.length * 120),
                    y: 150
                };
                this.mainCommits.push(commit);
                document.getElementById('main-commits').textContent = this.mainCommits.length;
                this.render();
            }

            createBranch() {
                if (!this.branchCreated && this.mainCommits.length > 0) {
                    this.branchCreated = true;
                    document.getElementById('branch-count').textContent = '2';
                    this.render();
                }
            }

            addCommitFeature() {
                if (!this.branchCreated) {
                    alert('Create a branch first!');
                    return;
                }
                this.commitCounter++;
                const baseX = 100 + (this.mainCommits.length - 1) * 120;
                const commit = {
                    id: this.commitCounter,
                    branch: 'feature',
                    x: baseX + (this.featureCommits.length + 1) * 120,
                    y: 250
                };
                this.featureCommits.push(commit);
                document.getElementById('feature-commits').textContent = this.featureCommits.length;
                this.render();
            }

            reset() {
                this.mainCommits = [];
                this.featureCommits = [];
                this.branchCreated = false;
                this.commitCounter = 0;
                this.canvas.innerHTML = '';
                document.getElementById('main-commits').textContent = '0';
                document.getElementById('feature-commits').textContent = '0';
                document.getElementById('branch-count').textContent = '1';
            }

            render() {
                this.canvas.innerHTML = '';

                // Draw arrows first (like MergeAnimation)
                // Main branch arrows
                for (let i = 1; i < this.mainCommits.length; i++) {
                    this.drawArrow(
                        this.mainCommits[i - 1].x + 35,
                        this.mainCommits[i - 1].y,
                        this.mainCommits[i].x - 35,
                        this.mainCommits[i].y,
                        'main'
                    );
                }

                // Branch point if exists
                if (this.branchCreated && this.mainCommits.length > 0 && this.featureCommits.length > 0) {
                    const branchPoint = this.mainCommits[this.mainCommits.length - 1];
                    
                    // Arrow from branch point to first feature commit
                    this.drawArrow(
                        branchPoint.x + 35,
                        branchPoint.y,
                        this.featureCommits[0].x - 35,
                        this.featureCommits[0].y,
                        'feature'
                    );

                    // Feature branch arrows
                    for (let i = 1; i < this.featureCommits.length; i++) {
                        this.drawArrow(
                            this.featureCommits[i - 1].x + 35,
                            this.featureCommits[i - 1].y,
                            this.featureCommits[i].x - 35,
                            this.featureCommits[i].y,
                            'feature'
                        );
                    }
                }

                // Draw all nodes on top of arrows (like MergeAnimation)
                this.mainCommits.forEach(commit => this.drawNode(commit));
                this.featureCommits.forEach(commit => this.drawNode(commit));

                // Add branch labels
                if (this.mainCommits.length > 0) {
                    const lastMain = this.mainCommits[this.mainCommits.length - 1];
                    this.drawBranchLabel('main', lastMain.x, lastMain.y - 60);
                }
                if (this.featureCommits.length > 0) {
                    const lastFeature = this.featureCommits[this.featureCommits.length - 1];
                    this.drawBranchLabel('feature', lastFeature.x, lastFeature.y + 60, true);
                }
            }

            drawNode(commit) {
                const node = document.createElement('div');
                node.className = `node ${commit.branch}`;
                node.style.left = `${commit.x - 35}px`;
                node.style.top = `${commit.y - 35}px`;
                node.innerHTML = `
                    <div class="label">${commit.branch}</div>
                    <div class="value">${commit.id}</div>
                `;
                this.canvas.appendChild(node);
            }

            drawArrow(x1, y1, x2, y2, type = 'main') {
                const arrow = document.createElement('div');
                arrow.className = 'arrow';
                const length = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
                const angle = Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI;
                
                arrow.style.width = `${length}px`;
                arrow.style.left = `${x1}px`;
                arrow.style.top = `${y1}px`;
                arrow.style.transform = `rotate(${angle}deg)`;
                
                // Match MergeAnimation style
                if (type === 'feature') {
                    arrow.style.background = 'rgba(79, 172, 254, 0.8)';
                } else if (type === 'main') {
                    arrow.style.background = 'rgba(102, 126, 234, 0.8)';
                }
                
                this.canvas.appendChild(arrow);
            }

            drawBranchLabel(text, x, y, isFeature = false) {
                const label = document.createElement('div');
                label.className = `branch-label ${isFeature ? 'feature' : ''}`;
                label.style.left = `${x - 30}px`;
                label.style.top = `${y}px`;
                label.textContent = text;
                this.canvas.appendChild(label);
            }
        }

        // Animation 2: Merge
        class MergeAnimation {
            constructor(canvasId) {
                this.canvas = document.getElementById(canvasId);
                this.commits = [];
                this.merged = false;
            }

            setup() {
                this.commits = [
                    { id: 1, branch: 'main', x: 100, y: 150, parents: [] },
                    { id: 2, branch: 'main', x: 220, y: 150, parents: [0] },
                    { id: 3, branch: 'feature', x: 340, y: 250, parents: [1] },
                    { id: 4, branch: 'feature', x: 460, y: 250, parents: [2] },
                    { id: 5, branch: 'main', x: 340, y: 150, parents: [1] }
                ];
                this.merged = false;
                document.getElementById('merge-count').textContent = '0';
                this.render();
            }

            merge() {
                if (this.commits.length === 0) {
                    alert('Setup branches first!');
                    return;
                }
                if (!this.merged) {
                    this.commits.push({
                        id: 6,
                        branch: 'merge',
                        x: 580,
                        y: 150,
                        parents: [4, 3] // Two parents: main and feature
                    });
                    this.merged = true;
                    document.getElementById('merge-count').textContent = '1';
                    this.render();
                }
            }

            reset() {
                this.commits = [];
                this.merged = false;
                this.canvas.innerHTML = '';
                document.getElementById('merge-count').textContent = '0';
            }

            render() {
                this.canvas.innerHTML = '';

                // Draw arrows first
                this.commits.forEach((commit, idx) => {
                    commit.parents.forEach(parentIdx => {
                        const parent = this.commits[parentIdx];
                        this.drawArrow(
                            parent.x + 35,
                            parent.y,
                            commit.x - 35,
                            commit.y,
                            commit.branch
                        );
                    });
                });

                // Draw nodes
                this.commits.forEach(commit => {
                    this.drawNode(commit);
                });
            }

            drawNode(commit) {
                const node = document.createElement('div');
                node.className = `node ${commit.branch}`;
                node.style.left = `${commit.x - 35}px`;
                node.style.top = `${commit.y - 35}px`;
                node.innerHTML = `
                    <div class="label">${commit.branch}</div>
                    <div class="value">${commit.id}</div>
                `;
                if (commit.branch === 'merge') {
                    node.classList.add('highlight');
                }
                this.canvas.appendChild(node);
            }

            drawArrow(x1, y1, x2, y2, type) {
                const arrow = document.createElement('div');
                arrow.className = 'arrow';
                const length = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
                const angle = Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI;
                
                arrow.style.width = `${length}px`;
                arrow.style.left = `${x1}px`;
                arrow.style.top = `${y1}px`;
                arrow.style.transform = `rotate(${angle}deg)`;
                
                if (type === 'merge') {
                    arrow.style.background = 'rgba(245, 87, 108, 0.8)';
                }
                
                this.canvas.appendChild(arrow);
            }
        }

        // Animation 3: Conflict
        class ConflictAnimation {
            constructor(canvasId) {
                this.canvas = document.getElementById(canvasId);
                this.commits = [];
                this.conflictDetected = false;
                this.resolved = false;
            }

            setup() {
                this.commits = [
                    { id: 1, branch: 'main', x: 100, y: 150, parents: [] },
                    { id: 2, branch: 'main', x: 250, y: 150, parents: [0], label: 'Original' },
                    { id: 3, branch: 'main', x: 400, y: 100, parents: [1], label: 'Main Change' },
                    { id: 4, branch: 'feature', x: 400, y: 200, parents: [1], label: 'Feature Change' }
                ];
                this.conflictDetected = false;
                this.resolved = false;
                document.getElementById('conflict-count').textContent = '0';
                document.getElementById('resolved-count').textContent = '0';
                document.getElementById('files-affected').textContent = '0';
                this.render();
            }

            attemptMerge() {
                if (this.commits.length === 0) {
                    alert('Setup branches first!');
                    return;
                }
                if (!this.conflictDetected) {
                    this.conflictDetected = true;
                    document.getElementById('conflict-count').textContent = '1';
                    document.getElementById('files-affected').textContent = '1';
                    document.getElementById('conflict-overlay').style.display = 'flex';
                    this.render();
                }
            }

            resolveConflict() {
                if (!this.conflictDetected) {
                    alert('No conflict to resolve!');
                    return;
                }
                document.getElementById('conflict-overlay').style.display = 'flex';
            }

            acceptResolution() {
                if (!this.resolved) {
                    this.commits.push({
                        id: 5,
                        branch: 'merge',
                        x: 550,
                        y: 150,
                        parents: [2, 3],
                        label: 'Resolved'
                    });
                    this.resolved = true;
                    document.getElementById('resolved-count').textContent = '1';
                    this.closeOverlay();
                    this.render();
                }
            }

            closeOverlay() {
                document.getElementById('conflict-overlay').style.display = 'none';
            }

            reset() {
                this.commits = [];
                this.conflictDetected = false;
                this.resolved = false;
                this.canvas.innerHTML = '';
                this.closeOverlay();
                document.getElementById('conflict-count').textContent = '0';
                document.getElementById('resolved-count').textContent = '0';
                document.getElementById('files-affected').textContent = '0';
            }

            render() {
                this.canvas.innerHTML = '';

                // Draw arrows
                this.commits.forEach((commit, idx) => {
                    commit.parents.forEach(parentIdx => {
                        const parent = this.commits[parentIdx];
                        this.drawArrow(parent.x + 35, parent.y, commit.x - 35, commit.y, commit.branch);
                    });
                });

                // Draw nodes
                this.commits.forEach(commit => {
                    this.drawNode(commit);
                });

                // Show conflict indicator
                if (this.conflictDetected && !this.resolved) {
                    const conflictLabel = document.createElement('div');
                    conflictLabel.style.cssText = `
                        position: absolute;
                        left: 50%;
                        top: 50%;
                        transform: translate(-50%, -50%);
                        padding: 20px 40px;
                        background: rgba(245, 87, 108, 0.2);
                        border: 2px solid #f5576c;
                        border-radius: 10px;
                        font-size: 1.5em;
                        color: #f5576c;
                        font-weight: bold;
                        animation: pulse 2s infinite;
                    `;
                    conflictLabel.textContent = '‚ö†Ô∏è CONFLICT';
                    this.canvas.appendChild(conflictLabel);
                }
            }

            drawNode(commit) {
                const node = document.createElement('div');
                node.className = `node ${commit.branch}`;
                node.style.left = `${commit.x - 35}px`;
                node.style.top = `${commit.y - 35}px`;
                node.innerHTML = `
                    <div class="label">${commit.label || commit.branch}</div>
                    <div class="value">${commit.id}</div>
                `;
                this.canvas.appendChild(node);
            }

            drawArrow(x1, y1, x2, y2, type) {
                const arrow = document.createElement('div');
                arrow.className = 'arrow';
                const length = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
                const angle = Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI;
                
                arrow.style.width = `${length}px`;
                arrow.style.left = `${x1}px`;
                arrow.style.top = `${y1}px`;
                arrow.style.transform = `rotate(${angle}deg)`;
                
                this.canvas.appendChild(arrow);
            }
        }

        // Animation 4: DAG
        class DAGAnimation {
            constructor(canvasId) {
                this.canvas = document.getElementById(canvasId);
                this.commits = [];
            }

            buildComplexGraph() {
                this.commits = [
                    // Main branch
                    { id: 1, branch: 'main', x: 100, y: 200, parents: [] },
                    { id: 2, branch: 'main', x: 200, y: 200, parents: [0] },
                    
                    // Feature 1 branch
                    { id: 3, branch: 'feature1', x: 300, y: 100, parents: [1] },
                    { id: 4, branch: 'feature1', x: 400, y: 100, parents: [2] },
                    
                    // Feature 2 branch
                    { id: 5, branch: 'feature2', x: 300, y: 300, parents: [1] },
                    { id: 6, branch: 'feature2', x: 400, y: 300, parents: [4] },
                    
                    // Main continues
                    { id: 7, branch: 'main', x: 300, y: 200, parents: [1] },
                    
                    // Merge feature1
                    { id: 8, branch: 'merge', x: 500, y: 150, parents: [3, 6] },
                    
                    // Merge feature2
                    { id: 9, branch: 'merge', x: 600, y: 200, parents: [7, 5] },
                    
                    // Final merge
                    { id: 10, branch: 'merge', x: 700, y: 175, parents: [8, 9] },
                    
                    // Continue main
                    { id: 11, branch: 'main', x: 800, y: 200, parents: [9] }
                ];

                document.getElementById('dag-commits').textContent = this.commits.length;
                document.getElementById('dag-merges').textContent = '3';
                document.getElementById('dag-branches').textContent = '3';
                
                this.render();
            }

            highlightPath() {
                if (this.commits.length === 0) {
                    alert('Build graph first!');
                    return;
                }
                
                // Highlight a path from commit 1 to commit 11
                const path = [0, 1, 6, 8, 9, 10];
                this.render(path);
            }

            reset() {
                this.commits = [];
                this.canvas.innerHTML = '';
                document.getElementById('dag-commits').textContent = '0';
                document.getElementById('dag-merges').textContent = '0';
                document.getElementById('dag-branches').textContent = '0';
            }

            render(highlightPath = []) {
                this.canvas.innerHTML = '';

                // Draw arrows
                this.commits.forEach((commit, idx) => {
                    commit.parents.forEach(parentIdx => {
                        const parent = this.commits[parentIdx];
                        const isHighlighted = highlightPath.includes(idx) && highlightPath.includes(parentIdx);
                        this.drawArrow(
                            parent.x + 35,
                            parent.y,
                            commit.x - 35,
                            commit.y,
                            commit.branch,
                            isHighlighted
                        );
                    });
                });

                // Draw nodes
                this.commits.forEach((commit, idx) => {
                    const isHighlighted = highlightPath.includes(idx);
                    this.drawNode(commit, isHighlighted);
                });
            }

            drawNode(commit, highlight = false) {
                const node = document.createElement('div');
                node.className = `node ${commit.branch}`;
                if (highlight) node.classList.add('highlight');
                node.style.left = `${commit.x - 35}px`;
                node.style.top = `${commit.y - 35}px`;
                node.innerHTML = `
                    <div class="value">${commit.id}</div>
                `;
                this.canvas.appendChild(node);
            }

            drawArrow(x1, y1, x2, y2, type, highlight = false) {
                const arrow = document.createElement('div');
                arrow.className = 'arrow';
                const length = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
                const angle = Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI;
                
                arrow.style.width = `${length}px`;
                arrow.style.left = `${x1}px`;
                arrow.style.top = `${y1}px`;
                arrow.style.transform = `rotate(${angle}deg)`;
                
                if (highlight) {
                    arrow.style.background = 'rgba(255, 215, 0, 0.9)';
                    arrow.style.height = '5px';
                }
                
                this.canvas.appendChild(arrow);
            }
        }

        // Code Typing Animation
        class CodeTypingAnimation {
            constructor(codeElement) {
                this.codeElement = codeElement;
                this.originalHTML = codeElement.innerHTML;
                this.hasAnimated = false;
            }

            animate() {
                if (this.hasAnimated) return;
                this.hasAnimated = true;

                this.codeElement.innerHTML = '';
                const lines = this.originalHTML.split('\n');
                let currentIndex = 0;

                const typeLine = () => {
                    if (currentIndex >= lines.length) return;

                    const line = lines[currentIndex];
                    const lineDiv = document.createElement('div');
                    lineDiv.className = 'code-line';
                    lineDiv.innerHTML = line;
                    this.codeElement.appendChild(lineDiv);

                    currentIndex++;
                    const delay = 30 + Math.random() * 50;
                    setTimeout(typeLine, delay);
                };

                typeLine();
            }
        }

        // Setup Intersection Observer for code blocks
        const setupCodeAnimations = () => {
            const codeBlocks = document.querySelectorAll('.code-display');
            const codeAnimations = [];

            codeBlocks.forEach(block => {
                const animation = new CodeTypingAnimation(block);
                codeAnimations.push({ element: block, animation });
            });

            const observer = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        const animation = codeAnimations.find(a => a.element === entry.target);
                        if (animation) {
                            animation.animation.animate();
                        }
                    }
                });
            }, { threshold: 0.3 });

            codeAnimations.forEach(({ element }) => {
                observer.observe(element);
            });
        };

        // Master Playback Controller for Voice-Over
        class PlaybackController {
            constructor() {
                this.isPlaying = false;
                this.isPaused = false;
                this.currentAct = 0;
                this.progressBar = document.getElementById('progress-bar');
                this.narrationIndicator = document.getElementById('narration-indicator');
                this.codeViewer = document.getElementById('code-viewer');
                this.codeViewerTitle = document.getElementById('code-viewer-title');
                this.codeViewerContent = document.getElementById('code-viewer-content');
            }

            async playAll() {
                if (this.isPlaying) return;
                this.isPlaying = true;
                this.isPaused = false;
                this.currentAct = 0;

                // Reset all animations first
                this.resetAll();
                
                // Show code viewer panel immediately
                this.codeViewer.classList.add('active');

                // Play sequence optimized for voice-over
                await this.playAct1();
                if (this.isPaused) return;
                
                await this.playAct2();
                if (this.isPaused) return;
                
                await this.playAct3();
                if (this.isPaused) return;
                
                await this.playAct4();
                if (this.isPaused) return;
                
                await this.playAct5();
                
                this.isPlaying = false;
                this.hideNarration();
                this.updateProgress(100);
            }

            async playAct1() {
                this.showNarration('Act 1: Branch Creation');
                this.highlightSection('section-1');
                this.updateProgress(10);
                this.scrollToSection('section-1');
                
                await this.wait(800);
                
                // Command 1: First commit
                await this.showCodeAndWait('<span class="cmd">git</span> commit -m <span class="string">"Initial commit"</span>', 'Starting with commits on main branch');
                await this.wait(500);
                branchAnimation.addCommitMain();
                await this.wait(800);
                
                // Command 2: Second commit
                await this.showCodeAndWait('<span class="cmd">git</span> commit -m <span class="string">"Add feature X"</span>', 'Building up the main branch');
                await this.wait(500);
                branchAnimation.addCommitMain();
                await this.wait(800);
                
                // Command 3: Create branch
                await this.showCodeAndWait('<span class="cmd">git</span> checkout -b feature/new-algorithm<br><span class="comment"># Creates a new branch pointing to current commit</span>', 'üåø Creating a new branch for parallel work');
                await this.wait(500);
                branchAnimation.createBranch();
                await this.wait(1000);
                
                // Command 4: Feature commit
                await this.showCodeAndWait('<span class="cmd">git</span> commit -m <span class="string">"Implement optimization"</span><br><span class="comment"># Feature branch moves forward independently</span>', 'Work continues on feature branch');
                await this.wait(500);
                branchAnimation.addCommitFeature();
                await this.wait(800);
                
                // Command 5: Main branch commit
                await this.showCodeAndWait('<span class="cmd">git</span> checkout main<br><span class="cmd">git</span> commit -m <span class="string">"Fix production bug"</span>', 'Meanwhile, main branch also progresses');
                await this.wait(500);
                branchAnimation.addCommitMain();
                await this.wait(800);
                
                // Command 6: Another feature commit
                await this.showCodeAndWait('<span class="cmd">git</span> checkout feature/new-algorithm<br><span class="cmd">git</span> commit -m <span class="string">"Add tests"</span>', 'Both branches evolving independently');
                await this.wait(500);
                branchAnimation.addCommitFeature();
                await this.wait(1000);
                
                this.unhighlightSection('section-1');
                this.updateProgress(25);
            }

            async playAct2() {
                this.showNarration('Act 2: Merge Commits');
                this.highlightSection('section-2');
                this.scrollToSection('section-2');
                
                await this.wait(800);
                
                // Setup: Show diverged branches
                await this.showCodeAndWait('<span class="comment"># Both branches have diverged</span><br><span class="comment"># Each has independent commits</span>', 'üìä Setting up diverged branches');
                await this.wait(500);
                mergeAnimation.setup();
                await this.wait(1200);
                
                // Show Python implementation
                await this.showCodeAndWait('<span class="keyword">def</span> <span class="function">find_merge_base</span>(commit_a, commit_b):<br>    <span class="comment"># LeetCode #160: Intersection of linked lists</span><br>    ancestors_a = <span class="function">set</span>()<br>    <span class="keyword">while</span> commit_a:<br>        ancestors_a.<span class="function">add</span>(commit_a)<br>        commit_a = commit_a.parent<br>    <span class="keyword">while</span> commit_b:<br>        <span class="keyword">if</span> commit_b <span class="keyword">in</span> ancestors_a:<br>            <span class="keyword">return</span> commit_b<br>        commit_b = commit_b.parent', 'üêç Python: Finding common ancestor');
                await this.wait(800);
                
                // Merge command
                await this.showCodeAndWait('<span class="cmd">git</span> checkout main<br><span class="cmd">git</span> merge feature/new-algorithm<br><br><span class="comment"># Creates merge commit with 2 parents</span>', 'üîÄ Merging feature branch back into main');
                await this.wait(600);
                mergeAnimation.merge();
                await this.wait(1200);
                
                // View history
                await this.showCodeAndWait('<span class="cmd">git</span> log --graph --oneline<br><br><span class="comment"># Diamond shape preserves full history</span>', '‚úÖ Full history maintained after merge');
                await this.wait(1000);
                this.unhighlightSection('section-2');
                this.updateProgress(45);
            }

            async playAct3() {
                this.showNarration('Act 3: Merge Conflicts');
                this.highlightSection('section-3');
                this.scrollToSection('section-3');
                
                await this.wait(800);
                
                // Setup: Show conflict scenario
                await this.showCodeAndWait('<span class="comment"># Problem: Both branches modified same file</span><br><span class="comment"># at the same location</span>', '‚ö†Ô∏è Conflicting changes detected');
                await this.wait(500);
                conflictAnimation.setup();
                await this.wait(1200);
                
                // Show Python conflict detection
                await this.showCodeAndWait('<span class="keyword">def</span> <span class="function">detect_conflicts</span>(base, ours, theirs):<br>    conflicts = []<br>    <span class="keyword">for</span> file <span class="keyword">in</span> <span class="function">set</span>(ours) | <span class="function">set</span>(theirs):<br>        <span class="keyword">if</span> ours[file] != theirs[file]:<br>            <span class="keyword">if</span> base[file] != ours[file] <span class="keyword">and</span><br>               base[file] != theirs[file]:<br>                conflicts.<span class="function">append</span>(file)<br>    <span class="keyword">return</span> conflicts', 'üêç Python: Three-way merge conflict detection');
                await this.wait(800);
                
                // Attempt merge - conflict occurs
                await this.showCodeAndWait('<span class="cmd">git</span> merge feature/new-algorithm<br><br><span style="color: #f5576c;">CONFLICT</span>: search_algorithm.py<br><span class="comment"># Git stops - manual fix required</span>', 'üõë Merge blocked by conflict');
                await this.wait(600);
                conflictAnimation.attemptMerge();
                await this.wait(2000);
                
                // Resolve and complete
                await this.showCodeAndWait('<span class="comment"># 1. Edit file, choose version</span><br><span class="cmd">git</span> add search_algorithm.py<br><span class="cmd">git</span> commit -m <span class="string">"Resolved conflict"</span>', '‚úÖ Manually resolving and completing');
                await this.wait(600);
                conflictAnimation.acceptResolution();
                await this.wait(1000);
                
                this.unhighlightSection('section-3');
                this.updateProgress(65);
            }

            async playAct4() {
                this.showNarration('Act 4: The DAG');
                this.highlightSection('section-4');
                this.scrollToSection('section-4');
                
                await this.wait(800);
                
                // Show Python DAG traversal
                await this.showCodeAndWait('<span class="keyword">def</span> <span class="function">traverse_dag</span>(commit, visited=<span class="keyword">None</span>):<br>    <span class="keyword">if</span> visited <span class="keyword">is</span> <span class="keyword">None</span>: visited = <span class="function">set</span>()<br>    <span class="keyword">if</span> commit <span class="keyword">in</span> visited: <span class="keyword">return</span><br>    visited.<span class="function">add</span>(commit)<br>    <span class="keyword">for</span> parent <span class="keyword">in</span> commit.parents:<br>        <span class="function">traverse_dag</span>(parent, visited)<br>    <span class="keyword">return</span> visited', 'üêç Python: DAG traversal (handles multiple parents)');
                await this.wait(800);
                
                // Build complex graph
                await this.showCodeAndWait('<span class="cmd">git</span> log --graph --all --oneline<br><br><span class="comment"># Multiple branches, multiple merges</span>', 'üï∏Ô∏è Building complex Directed Acyclic Graph');
                await this.wait(600);
                dagAnimation.buildComplexGraph();
                await this.wait(1500);
                
                // Trace path
                await this.showCodeAndWait('<span class="cmd">git</span> log --graph commit1..commit11<br><br><span class="comment"># DAG preserves full history, enables parallel work</span>', 'üîç Tracing paths through the history');
                await this.wait(600);
                dagAnimation.highlightPath();
                await this.wait(1200);
                
                this.unhighlightSection('section-4');
                this.updateProgress(85);
            }

            async playAct5() {
                this.showNarration('Final Lesson');
                this.highlightSection('section-5');
                this.scrollToSection('section-5');
                
                await this.wait(1000);
                
                await this.showCodeAndWait('<span class="comment"># Git\'s DAG Model:</span><br><br><span class="cmd">‚úì</span> Branching - Zero-cost parallel work<br><span class="cmd">‚úì</span> Merging - Preserve full history<br><span class="cmd">‚úì</span> Conflicts - Detect overlapping changes<br><span class="cmd">‚úì</span> DAG - Scale to millions of commits<br><br><span class="comment"># This is why Git won.</span><br><span class="comment"># Linear history doesn\'t scale.</span>', 'üéì The power of the DAG');
                
                await this.wait(3000);
                
                this.unhighlightSection('section-5');
            }

            wait(ms) {
                return new Promise(resolve => {
                    const checkPause = setInterval(() => {
                        if (!this.isPaused) {
                            clearInterval(checkPause);
                            setTimeout(resolve, ms);
                        }
                    }, 100);
                });
            }

            pause() {
                this.isPaused = true;
                this.narrationIndicator.textContent = '‚è∏ PAUSED';
            }

            resetAll() {
                this.isPaused = false;
                this.isPlaying = false;
                branchAnimation.reset();
                mergeAnimation.reset();
                conflictAnimation.reset();
                dagAnimation.reset();
                this.updateProgress(0);
                this.hideNarration();
                this.codeViewerContent.innerHTML = ''; // Clear command history on reset
                this.hideCode();
                document.querySelectorAll('.section').forEach(s => s.classList.remove('active-narration'));
            }

            showNarration(text) {
                this.narrationIndicator.textContent = `üé¨ ${text}`;
                this.narrationIndicator.classList.add('active');
            }

            hideNarration() {
                this.narrationIndicator.classList.remove('active');
            }

            highlightSection(sectionId) {
                document.querySelectorAll('.section').forEach(s => s.classList.remove('active-narration'));
                document.getElementById(sectionId)?.classList.add('active-narration');
            }

            unhighlightSection(sectionId) {
                document.getElementById(sectionId)?.classList.remove('active-narration');
            }

            scrollToSection(sectionId) {
                const section = document.getElementById(sectionId);
                if (section) {
                    section.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }
            }

            updateProgress(percent) {
                this.progressBar.style.width = `${percent}%`;
            }

            showCode(title, content, subtitle = 'Watch what\'s happening...') {
                const titleElement = document.getElementById('code-viewer-title');
                titleElement.innerHTML = `üìù Live Commands<div class="code-viewer-subtitle">${subtitle}</div>`;
                // Don't clear - append to keep history
                // Add separator if there's already content
                if (this.codeViewerContent.innerHTML.trim() !== '') {
                    this.codeViewerContent.innerHTML += '<div class="separator"></div>';
                }
                this.codeViewer.classList.add('active');
                this.typeCode(content);
            }

            async showCodeAndWait(content, subtitle = 'Watch what\'s happening...') {
                const titleElement = document.getElementById('code-viewer-title');
                titleElement.innerHTML = `üìù Live Commands<div class="code-viewer-subtitle">${subtitle}</div>`;
                // Don't clear - append to keep history
                // Add separator if there's already content
                if (this.codeViewerContent.innerHTML.trim() !== '') {
                    this.codeViewerContent.innerHTML += '<div class="separator"></div>';
                }
                this.codeViewer.classList.add('active');
                // Wait for typing to complete
                await this.typeCode(content);
            }

            async typeCode(htmlContent) {
                // Parse HTML to preserve formatting while typing
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = htmlContent;
                
                const textContent = tempDiv.textContent || tempDiv.innerText;
                const lines = htmlContent.split('<br>');
                
                // Store the starting position for this command block
                const startLength = this.codeViewerContent.innerHTML.length;
                
                for (let i = 0; i < lines.length; i++) {
                    if (i > 0) {
                        this.codeViewerContent.innerHTML += '<br>';
                    }
                    
                    // Create a temporary div to parse this line
                    const lineDiv = document.createElement('div');
                    lineDiv.innerHTML = lines[i];
                    
                    // Type this line with formatting
                    await this.typeHTMLLine(lines[i]);
                    
                    // Auto-scroll to bottom as new content is added
                    this.codeViewer.scrollTop = this.codeViewer.scrollHeight;
                    
                    if (this.isPaused) return;
                }
            }

            async typeHTMLLine(htmlLine) {
                // Split HTML into tokens (tags and text)
                const tokens = [];
                const regex = /(<[^>]+>)|([^<]+)/g;
                let match;
                
                while ((match = regex.exec(htmlLine)) !== null) {
                    tokens.push(match[0]);
                }
                
                // Get existing content to preserve it
                let existingContent = this.codeViewerContent.innerHTML.replace(/<span class="typing-cursor"><\/span>/g, '');
                let newLineContent = '';
                
                for (const token of tokens) {
                    if (token.startsWith('<') && token.endsWith('>')) {
                        // It's a tag, add it instantly
                        newLineContent += token;
                        this.codeViewerContent.innerHTML = existingContent + newLineContent;
                    } else {
                        // It's text, type character by character
                        for (const char of token) {
                            newLineContent += char;
                            this.codeViewerContent.innerHTML = existingContent + newLineContent + '<span class="typing-cursor"></span>';
                            // Faster typing: 50-80ms per character for better pacing
                            await new Promise(resolve => setTimeout(resolve, 50 + Math.random() * 30));
                            if (this.isPaused) return;
                        }
                    }
                }
                
                // Remove cursor after line is complete, keep all content
                this.codeViewerContent.innerHTML = existingContent + newLineContent;
            }

            hideCode() {
                this.codeViewer.classList.remove('active');
            }
        }

        // Initialize all animations
        const branchAnimation = new BranchAnimation('canvas1');
        const mergeAnimation = new MergeAnimation('canvas2');
        const conflictAnimation = new ConflictAnimation('canvas3');
        const dagAnimation = new DAGAnimation('canvas4');
        const playbackController = new PlaybackController();

        // Setup code typing animations when page loads
        window.addEventListener('DOMContentLoaded', () => {
            setupCodeAnimations();
        });
    </script>
</body>
</html>
