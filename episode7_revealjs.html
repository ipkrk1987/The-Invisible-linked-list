<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Episode 7: Ring Buffers ‚Äì When Data Never Stops</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.5.0/reset.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.5.0/reveal.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.5.0/theme/black.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/monokai.min.css">
    <style>
        :root {
            --primary: #4facfe;
            --secondary: #00f2fe;
            --accent: #f093fb;
            --warning: #ffeaa7;
            --danger: #ff6b6b;
            --success: #00b894;
            --bg-dark: #1a1a2e;
        }
        .reveal {
            font-family: 'Segoe UI', system-ui, sans-serif;
        }
        .reveal h1, .reveal h2, .reveal h3 {
            text-transform: none;
            font-weight: 700;
        }
        .reveal h1 {
            font-size: 2.2em;
            background: linear-gradient(90deg, var(--primary), var(--secondary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        .reveal h2 {
            font-size: 1.6em;
            color: var(--primary);
        }
        .reveal h3 {
            font-size: 1.3em;
            color: var(--secondary);
        }
        .reveal pre {
            width: 100%;
            font-size: 0.5em;
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
            border-radius: 12px;
        }
        .reveal code {
            font-family: 'Fira Code', 'Consolas', monospace;
        }
        .highlight-box {
            background: rgba(79, 172, 254, 0.1);
            border: 2px solid var(--primary);
            border-radius: 12px;
            padding: 20px;
            margin: 20px 0;
        }
        .warning-box {
            background: rgba(255, 107, 107, 0.1);
            border: 2px solid var(--danger);
            border-radius: 12px;
            padding: 20px;
            margin: 20px 0;
        }
        .success-box {
            background: rgba(0, 184, 148, 0.1);
            border: 2px solid var(--success);
            border-radius: 12px;
            padding: 20px;
            margin: 20px 0;
        }
        .comparison-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }
        .comparison-box {
            background: rgba(255,255,255,0.05);
            border-radius: 12px;
            padding: 20px;
        }
        .comparison-box.bad {
            border: 2px solid var(--danger);
        }
        .comparison-box.good {
            border: 2px solid var(--success);
        }
        .stat-number {
            font-size: 2.5em;
            font-weight: 800;
            background: linear-gradient(90deg, var(--primary), var(--secondary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        .badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.7em;
            font-weight: 600;
            margin: 0 5px;
        }
        .badge-blue { background: var(--primary); color: #000; }
        .badge-green { background: var(--success); color: #000; }
        .badge-red { background: var(--danger); color: #fff; }
        .badge-yellow { background: var(--warning); color: #000; }
        blockquote {
            background: rgba(79, 172, 254, 0.1);
            border-left: 4px solid var(--primary);
            padding: 20px;
            font-style: italic;
            border-radius: 0 12px 12px 0;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.7em;
        }
        th, td {
            padding: 10px;
            text-align: left;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        th {
            background: rgba(79, 172, 254, 0.2);
            color: var(--primary);
        }
        .two-column {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            align-items: start;
        }
    </style>
</head>
<body>
    <div class="reveal">
        <div class="slides">
            <!-- Title Slide -->
            <section>
                <h1>‚≠ï Episode 7: Ring Buffers</h1>
                <h3>When Data Never Stops ‚Äî Bounded Queues & Producer-Consumer</h3>
                <p style="opacity: 0.7; margin-top: 40px;">Season 1: The Invisible Linked List</p>
                <div style="margin-top: 40px;">
                    <span class="badge badge-blue">Circular Queue</span>
                    <span class="badge badge-green">Producer-Consumer</span>
                    <span class="badge badge-yellow">LeetCode #622</span>
                </div>
            </section>

            <!-- Act 1: The Infinite Stream Problem -->
            <section>
                <section>
                    <h2>Act 1: Data That Never Stops</h2>
                    <blockquote>
                        "All season we assumed data stops arriving. LRU keeps recent items. 
                        Browser history has endpoints. But what if it doesn't stop?"
                    </blockquote>
                </section>

                <section>
                    <h2>Six Episodes In ‚Äî What We've Mastered</h2>
                    <div class="highlight-box">
                        <p>üìú Episode 1-2: Storing linear history (Git)</p>
                        <p>üîÑ Episode 3: Navigating bidirectionally (Browser)</p>
                        <p>‚è™ Episode 4: Time travel (Undo/Redo)</p>
                        <p>üß† Episode 5: Deciding what to keep (LRU)</p>
                        <p>üåê Episode 6: Distributing across systems (CDN)</p>
                    </div>
                    <p class="fragment" style="color: var(--secondary); font-size: 1.2em; margin-top: 20px;">
                        All assume data <strong>eventually stops arriving</strong>. What if it doesn't?
                    </p>
                </section>

                <section>
                    <h2>Real-World Infinite Streams</h2>
                    <div class="highlight-box">
                        <p>üìà <strong>Stock tickers:</strong> 100,000 trades/second</p>
                        <p>üìπ <strong>Video streaming:</strong> 60 fps √ó 8MB/frame = 480MB/s</p>
                        <p>üìä <strong>Server logs:</strong> 10,000 lines/sec √ó 1,000 servers</p>
                        <p>üåê <strong>Network packets:</strong> 1,000,000 packets/sec on 10Gbps</p>
                    </div>
                    <p class="fragment" style="color: var(--danger); font-size: 1.2em;">
                        You can't store infinite data. You need <strong>bounded buffers</strong>.
                    </p>
                </section>

                <section>
                    <h2>Why Unbounded Queues Kill Systems</h2>
                    <pre><code class="language-python">queue = []
while True:
    data = receive_data()      # 100,000/sec
    queue.append(data)
    process(queue.pop(0))      # Takes 0.00002 seconds</code></pre>
                    <div class="fragment warning-box">
                        <p><strong>The Math:</strong></p>
                        <p>Producer: 100,000 items/sec</p>
                        <p>Consumer: 90,000 items/sec (slightly slower!)</p>
                        <p>Net accumulation: 10,000 items/sec</p>
                        <p>After 1 hour: <strong>36,000,000 items ‚Üí OOM!</strong></p>
                    </div>
                </section>
            </section>

            <!-- Act 2: Ring Buffer Theory -->
            <section>
                <section>
                    <h2>Act 2: Ring Buffer Theory</h2>
                    <h3>The Elegant Solution</h3>
                </section>

                <section>
                    <h2>Bounded Queue Strategies</h2>
                    <table>
                        <tr>
                            <th>Strategy</th>
                            <th>Behavior</th>
                            <th>Use Case</th>
                        </tr>
                        <tr>
                            <td><strong>Block producer</strong></td>
                            <td>Wait until space</td>
                            <td>Critical data (finance)</td>
                        </tr>
                        <tr>
                            <td><strong>Drop oldest</strong></td>
                            <td>Overwrite oldest</td>
                            <td>Time-series (metrics)</td>
                        </tr>
                        <tr>
                            <td><strong>Drop newest</strong></td>
                            <td>Reject new item</td>
                            <td>When history matters</td>
                        </tr>
                        <tr>
                            <td><strong>Sample</strong></td>
                            <td>Keep every Nth</td>
                            <td>High-volume analytics</td>
                        </tr>
                        <tr>
                            <td><strong>Backpressure</strong></td>
                            <td>Signal upstream</td>
                            <td>Distributed systems</td>
                        </tr>
                    </table>
                </section>

                <section>
                    <h2>Ring Buffer: The Core Insight</h2>
                    <pre><code class="language-text">Linear view (wasteful):
[A][B][C][_][_][_][_][_] ‚Üí needs reallocation

Ring view (bounded):
     tail (read)
       ‚Üì
    ‚îå‚îÄ‚îÄ[A]‚îÄ‚îÄ[B]‚îÄ‚îÄ‚îê
    ‚îÇ            ‚îÇ
   [_]          [C]
    ‚îÇ            ‚îÇ
    ‚îî‚îÄ‚îÄ[_]‚îÄ‚îÄ[_]‚îÄ‚îÄ‚îò
          ‚Üë
        head (write)

When head reaches end ‚Üí wrap to beginning!</code></pre>
                </section>

                <section>
                    <h2>Ring Buffer Mathematics</h2>
                    <pre><code class="language-text">Capacity: 8
Buffer: [A, B, C, D, _, _, _, _]
         ^              ^
        tail           head
        (read)         (write)</code></pre>
                    <div class="highlight-box">
                        <p><strong>Key Invariants:</strong></p>
                        <p>1. <code>head</code> points to next write position</p>
                        <p>2. <code>tail</code> points to next read position</p>
                        <p>3. Size: <code>(head - tail + capacity) % capacity</code></p>
                        <p>4. Full when: <code>(head + 1) % capacity == tail</code></p>
                    </div>
                </section>

                <section>
                    <h2>The Magic: Wrap-Around</h2>
                    <pre><code class="language-text">After writing E, F, G, H, I:

[I, B, C, D, E, F, G, H]
    ^
   tail
 ^
head (wrapped around!)

After reading B, C, D:

[I, _, _, _, E, F, G, H]
             ^
            tail
 ^
head</code></pre>
                    <p class="fragment success-box">
                        <strong>O(1) push, O(1) pop, fixed memory forever!</strong>
                    </p>
                </section>

                <section>
                    <h2>Ring Buffer Complexity</h2>
                    <table>
                        <tr>
                            <th>Operation</th>
                            <th>Ring Buffer</th>
                            <th>Dynamic Array</th>
                        </tr>
                        <tr>
                            <td>Read (pop)</td>
                            <td>O(1)</td>
                            <td>O(1)</td>
                        </tr>
                        <tr>
                            <td>Write (push)</td>
                            <td>O(1)</td>
                            <td>O(1) amortized</td>
                        </tr>
                        <tr>
                            <td>Memory</td>
                            <td><strong>O(capacity)</strong></td>
                            <td>O(n) unbounded</td>
                        </tr>
                        <tr>
                            <td>Allocation</td>
                            <td><strong>O(0) runtime</strong></td>
                            <td>O(n) resizes</td>
                        </tr>
                    </table>
                    <p class="fragment" style="color: var(--success);">
                        <strong>Bonus:</strong> Cache-friendly ‚Äî sequential memory access!
                    </p>
                </section>

                <section>
                    <h2>Little's Law ‚Äî Queue Sizing</h2>
                    <div class="highlight-box">
                        <p style="font-size: 1.5em;"><strong>L = Œª √ó W</strong></p>
                        <p>L = Average items in queue</p>
                        <p>Œª = Arrival rate (items/sec)</p>
                        <p>W = Processing time (sec/item)</p>
                    </div>
                    <div class="fragment">
                        <p><strong>Example:</strong> 1000 req/sec, 0.01 sec processing</p>
                        <p>L = 1000 √ó 0.01 = <strong>10 items average</strong></p>
                        <p style="color: var(--secondary);">Buffer capacity = L √ó 2-3 (for variance)</p>
                    </div>
                </section>
            </section>

            <!-- Act 3: Implementation -->
            <section>
                <section>
                    <h2>Act 3: Ring Buffer Implementation</h2>
                    <h3>From LeetCode to Production</h3>
                </section>

                <section>
                    <h2>LeetCode #622: Design Circular Queue</h2>
                    <pre><code class="language-python">class MyCircularQueue:
    def __init__(self, k: int):
        self.capacity = k
        self.queue = [None] * k
        self.head = 0
        self.tail = 0
        self.size = 0
    
    def enQueue(self, value: int) -> bool:
        if self.isFull():
            return False
        self.queue[self.tail] = value
        self.tail = (self.tail + 1) % self.capacity
        self.size += 1
        return True
    
    def deQueue(self) -> bool:
        if self.isEmpty():
            return False
        self.head = (self.head + 1) % self.capacity
        self.size -= 1
        return True</code></pre>
                    <p class="fragment" style="color: var(--secondary);">
                        This is the interview question. Now let's see production...
                    </p>
                </section>

                <section>
                    <h2>Production RingBuffer</h2>
                    <pre><code class="language-python">class RingBuffer:
    def __init__(self, capacity: int):
        self.capacity = capacity
        self.buffer = [None] * capacity
        self.head = 0  # Next write position
        self.tail = 0  # Next read position
        self.size = 0
    
    def push(self, item) -> bool:
        if self.size == self.capacity:
            return False  # Buffer full
        self.buffer[self.head] = item
        self.head = (self.head + 1) % self.capacity
        self.size += 1
        return True
    
    def pop(self):
        if self.size == 0:
            return None
        item = self.buffer[self.tail]
        self.buffer[self.tail] = None  # Clear reference (GC)
        self.tail = (self.tail + 1) % self.capacity
        self.size -= 1
        return item</code></pre>
                </section>

                <section>
                    <h2>OverwritingRingBuffer</h2>
                    <pre><code class="language-python">class OverwritingRingBuffer(RingBuffer):
    """Always succeeds ‚Äî overwrites oldest when full."""
    
    def push(self, item) -> bool:
        if self.size == self.capacity:
            # Overwrite oldest: advance tail too
            self.buffer[self.head] = item
            self.head = (self.head + 1) % self.capacity
            self.tail = (self.tail + 1) % self.capacity
            # size stays the same
        else:
            self.buffer[self.head] = item
            self.head = (self.head + 1) % self.capacity
            self.size += 1
        return True  # Always succeeds!</code></pre>
                    <div class="fragment highlight-box">
                        <strong>Use cases:</strong> Metrics, logs, real-time analytics ‚Äî recent data matters most
                    </div>
                </section>

                <section>
                    <h2>Thread-Safe BoundedBlockingQueue</h2>
                    <pre><code class="language-python">class BoundedBlockingQueue:
    def __init__(self, capacity):
        self.queue = collections.deque()
        self.capacity = capacity
        self.lock = threading.Lock()
        self.not_empty = threading.Condition(self.lock)
        self.not_full = threading.Condition(self.lock)
    
    def put(self, item, timeout=None):
        with self.not_full:
            while len(self.queue) == self.capacity:
                self.not_full.wait(timeout)  # Block!
            self.queue.append(item)
            self.not_empty.notify()
    
    def get(self, timeout=None):
        with self.not_empty:
            while not self.queue:
                self.not_empty.wait(timeout)  # Block!
            item = self.queue.popleft()
            self.not_full.notify()
            return item</code></pre>
                </section>

                <section>
                    <h2>Producer-Consumer Pattern</h2>
                    <pre><code class="language-python">class ProducerConsumerSystem:
    def __init__(self, buffer_capacity=1000):
        self.buffer = BoundedBlockingQueue(buffer_capacity)
        self.running = False
    
    def _producer_worker(self, source):
        while self.running:
            item = source.get_next()
            try:
                self.buffer.put(item, timeout=0.1)
            except Full:
                self.dropped += 1  # Track drops
    
    def _consumer_worker(self, processor):
        while self.running:
            item = self.buffer.get(timeout=1.0)
            if item:
                processor.process(item)</code></pre>
                    <p class="fragment success-box">
                        <strong>This pattern is everywhere:</strong> Web servers, databases, log processors, video encoders
                    </p>
                </section>
            </section>

            <!-- Act 4: Production Systems -->
            <section>
                <section>
                    <h2>Act 4: Production Logging & Metrics</h2>
                </section>

                <section>
                    <h2>LogBufferSystem</h2>
                    <pre><code class="language-python">class LogBufferSystem:
    def __init__(self, buffer_capacity=10000, flush_threshold=1000):
        self.buffer = OverwritingRingBuffer(buffer_capacity)
        self.batch = []
        self.flush_threshold = flush_threshold
    
    def log(self, level, message, **kwargs):
        entry = {
            'timestamp': time.time(),
            'level': level,
            'message': message,
            **kwargs
        }
        self.buffer.push(entry)
        self.batch.append(entry)
        
        if len(self.batch) >= self.flush_threshold:
            self._flush_batch()</code></pre>
                    <div class="fragment highlight-box">
                        <strong>Key insight:</strong> Batch writes are 100√ó more efficient than individual writes!
                    </div>
                </section>

                <section>
                    <h2>MetricsBuffer for Time-Series</h2>
                    <pre><code class="language-python">class MetricsBuffer:
    def __init__(self, window_seconds=300, resolution_ms=1000):
        # 5 minutes @ 1-second resolution = 300 buckets
        self.window_size = window_seconds * 1000 // resolution_ms
        self.buffer = OverwritingRingBuffer(self.window_size)
        self.current_bucket = {}
    
    def record(self, metric_name, value):
        bucket_time = self._current_bucket_time()
        
        if bucket_time != self.bucket_start:
            self._flush_bucket()
        
        # Aggregate in current bucket
        if metric_name not in self.current_bucket:
            self.current_bucket[metric_name] = {'sum': 0, 'count': 0}
        self.current_bucket[metric_name]['sum'] += value
        self.current_bucket[metric_name]['count'] += 1</code></pre>
                    <p class="fragment" style="color: var(--secondary);">
                        <strong>Used in:</strong> Prometheus, StatsD, DataDog agents
                    </p>
                </section>

                <section>
                    <h2>Key Takeaways</h2>
                    <div class="highlight-box">
                        <p>1. <strong>Fixed size</strong> ‚Äî No memory growth, ever</p>
                        <p>2. <strong>Wrap-around</strong> ‚Äî Head and tail chase each other</p>
                        <p>3. <strong>O(1) everything</strong> ‚Äî Push, pop, no allocations</p>
                        <p>4. <strong>Choose your strategy</strong> ‚Äî Block, drop, or backpressure</p>
                    </div>
                    <div class="fragment success-box">
                        <p><strong>Production patterns:</strong></p>
                        <p>‚Ä¢ Logging: Overwriting buffer + batch flush</p>
                        <p>‚Ä¢ Metrics: Time-bucketed aggregation</p>
                        <p>‚Ä¢ Queues: Producer-consumer with blocking</p>
                    </div>
                </section>
            </section>

            <!-- Epilogue -->
            <section>
                <section>
                    <h2>Next Episode: Streaming & Kafka</h2>
                    <div class="highlight-box">
                        <p>üìπ <strong>Video streaming</strong> with jitter buffers</p>
                        <p>üìä <strong>Kafka-style</strong> distributed logs</p>
                        <p>‚ö° <strong>Backpressure</strong> strategies at scale</p>
                        <p>üé¨ <strong>Season 1 Finale</strong> ‚Äî Complete retrospective</p>
                    </div>
                    <blockquote class="fragment" style="margin-top: 30px;">
                        "Ring buffers are the foundation. Kafka scales them to trillions of messages per day. 
                        And video players use them to make your Netflix buttery smooth."
                    </blockquote>
                    <p style="font-size: 1.5em; margin-top: 30px;">See you in Episode 8! üöÄ</p>
                </section>
            </section>

        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.5.0/reveal.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.5.0/plugin/highlight/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.5.0/plugin/notes/notes.min.js"></script>
    <script>
        Reveal.initialize({
            hash: true,
            slideNumber: 'c/t',
            plugins: [RevealHighlight, RevealNotes],
            transition: 'slide',
            backgroundTransition: 'fade'
        });
    </script>
</body>
</html>
