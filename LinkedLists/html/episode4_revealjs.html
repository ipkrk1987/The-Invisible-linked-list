<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Episode 4: Time Travel ‚Äì Immutable Data Structures Power Modern Undo</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.5.0/reset.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.5.0/reveal.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.5.0/theme/black.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/monokai.min.css">
    <style>
        :root {
            --primary: #4facfe;
            --secondary: #00f2fe;
            --accent: #f093fb;
            --warning: #ffeaa7;
            --danger: #ff6b6b;
            --success: #00b894;
            --bg-dark: #1a1a2e;
        }
        .reveal {
            font-family: 'Segoe UI', system-ui, sans-serif;
        }
        .reveal h1, .reveal h2, .reveal h3 {
            text-transform: none;
            font-weight: 700;
        }
        .reveal h1 {
            font-size: 2.2em;
            background: linear-gradient(90deg, var(--primary), var(--secondary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        .reveal h2 {
            font-size: 1.6em;
            color: var(--primary);
        }
        .reveal h3 {
            font-size: 1.3em;
            color: var(--secondary);
        }
        .reveal pre {
            width: 100%;
            font-size: 0.5em;
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
            border-radius: 12px;
        }
        .reveal code {
            font-family: 'Fira Code', 'Consolas', monospace;
        }
        .gradient-text {
            background: linear-gradient(90deg, var(--primary), var(--secondary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        .highlight-box {
            background: rgba(79, 172, 254, 0.1);
            border: 2px solid var(--primary);
            border-radius: 12px;
            padding: 20px;
            margin: 20px 0;
        }
        .warning-box {
            background: rgba(255, 107, 107, 0.1);
            border: 2px solid var(--danger);
            border-radius: 12px;
            padding: 20px;
            margin: 20px 0;
        }
        .success-box {
            background: rgba(0, 184, 148, 0.1);
            border: 2px solid var(--success);
            border-radius: 12px;
            padding: 20px;
            margin: 20px 0;
        }
        .comparison-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }
        .comparison-box {
            background: rgba(255,255,255,0.05);
            border-radius: 12px;
            padding: 20px;
        }
        .comparison-box.bad {
            border: 2px solid var(--danger);
        }
        .comparison-box.good {
            border: 2px solid var(--success);
        }
        .stat-number {
            font-size: 2.5em;
            font-weight: 800;
            background: linear-gradient(90deg, var(--primary), var(--secondary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        .timeline {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            margin: 20px 0;
            flex-wrap: wrap;
        }
        .timeline-node {
            background: var(--primary);
            color: #000;
            padding: 10px 20px;
            border-radius: 8px;
            font-weight: 600;
        }
        .timeline-arrow {
            color: var(--secondary);
            font-size: 1.5em;
        }
        .animation-container {
            width: 100%;
            height: 400px;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
        }
        .canvas-container {
            position: relative;
        }
        canvas {
            border-radius: 12px;
            background: rgba(0,0,0,0.3);
        }
        .badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.7em;
            font-weight: 600;
            margin: 0 5px;
        }
        .badge-blue { background: var(--primary); color: #000; }
        .badge-green { background: var(--success); color: #000; }
        .badge-red { background: var(--danger); color: #fff; }
        .badge-yellow { background: var(--warning); color: #000; }
        blockquote {
            background: rgba(79, 172, 254, 0.1);
            border-left: 4px solid var(--primary);
            padding: 20px;
            font-style: italic;
            border-radius: 0 12px 12px 0;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.7em;
        }
        th, td {
            padding: 10px;
            text-align: left;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        th {
            background: rgba(79, 172, 254, 0.2);
            color: var(--primary);
        }
        .fragment.highlight-current-blue.current-fragment {
            color: var(--primary);
        }
        .two-column {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            align-items: start;
        }
        .version-box {
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 8px;
            padding: 15px;
            margin: 10px 0;
            font-family: monospace;
            font-size: 0.8em;
        }
        .tree-node {
            display: inline-block;
            background: var(--primary);
            color: #000;
            padding: 8px 16px;
            border-radius: 8px;
            margin: 5px;
            font-weight: 600;
        }
        .tree-node.new {
            background: var(--success);
        }
        .tree-node.shared {
            background: var(--secondary);
        }
        .memory-bar {
            height: 30px;
            background: rgba(255,255,255,0.1);
            border-radius: 15px;
            overflow: hidden;
            margin: 10px 0;
        }
        .memory-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--success), var(--primary));
            transition: width 0.5s ease;
        }
        .memory-fill.danger {
            background: linear-gradient(90deg, var(--warning), var(--danger));
        }
    </style>
</head>
<body>
    <div class="reveal">
        <div class="slides">
            <!-- Title Slide -->
            <section>
                <h1>üïê Episode 4: Time Travel</h1>
                <h3>How Immutable Data Structures Power Modern Undo Systems</h3>
                <p style="opacity: 0.7; margin-top: 40px;">Season 1: The Invisible Linked List</p>
                <div class="timeline" style="margin-top: 40px;">
                    <span class="badge badge-blue">Redux</span>
                    <span class="badge badge-green">Git</span>
                    <span class="badge badge-yellow">Figma</span>
                    <span class="badge badge-blue">CRDTs</span>
                </div>
            </section>

            <!-- Act 1: The Problem -->
            <section>
                <section>
                    <h2>Act 1: The Scale Challenge</h2>
                    <blockquote>
                        "The real challenge isn't implementing undo. It's implementing undo across 50,000 concurrent users without corrupting state, losing history, or melting your servers."
                    </blockquote>
                </section>

                <section>
                    <h2>You're Building Google Docs</h2>
                    <div class="highlight-box">
                        <p>Every keystroke must be undoable</p>
                        <p>50 users typing simultaneously</p>
                        <p>Branching undo (undo ‚Üí type ‚Üí new branch)</p>
                        <p>Redo must handle conflicts</p>
                        <p>History must survive crashes</p>
                        <p>Time travel debugging for any state</p>
                    </div>
                </section>

                <section>
                    <h2>Traditional Approaches FAIL</h2>
                    <div class="comparison-grid">
                        <div class="comparison-box bad">
                            <h3 style="color: var(--danger);">Deep Copy</h3>
                            <p>100MB doc √ó 1000 edits/sec</p>
                            <p class="stat-number" style="color: var(--danger);">100GB/s</p>
                            <p>memory churn üí•</p>
                        </div>
                        <div class="comparison-box bad">
                            <h3 style="color: var(--danger);">Deltas Only</h3>
                            <p>Access state #5000?</p>
                            <p>Replay 5000 deltas</p>
                            <p class="stat-number" style="color: var(--danger);">O(n)</p>
                            <p>seek time üí•</p>
                        </div>
                    </div>
                </section>

                <section>
                    <h2>Mutation = Race Conditions</h2>
                    <pre><code class="language-python">THREAD A                    THREAD B
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ                    ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
read self.current = 5
                            read self.current = 5
slice history[:6]
                            slice history[:6]
append "page_A"
                            append "page_B"
self.current = 6
                            self.current = 6

# RESULT: Only one page survives! Data loss!</code></pre>
                    <p class="fragment" style="color: var(--danger); font-size: 1.2em; margin-top: 20px;">
                        In production with concurrent users, mutation is a ticking time bomb.
                    </p>
                </section>

                <section>
                    <h2>What We Need</h2>
                    <div class="success-box">
                        <p>‚úì Instant undo/redo ‚Äî O(1) or O(log n)</p>
                        <p>‚úì Branching undo ‚Äî both paths preserved</p>
                        <p>‚úì Concurrent safe ‚Äî no race conditions</p>
                        <p>‚úì Memory efficient ‚Äî not 100GB for 1000 edits</p>
                        <p>‚úì Crash recovery ‚Äî history survives restarts</p>
                        <p>‚úì Collaborative ‚Äî 50 users, consistent state</p>
                        <p>‚úì Time travel ‚Äî jump to ANY version instantly</p>
                    </div>
                </section>
            </section>

            <!-- Act 2: LeetCode Foundation -->
            <section>
                <section>
                    <h2>Act 2: The LeetCode Foundation</h2>
                    <h3>LeetCode #1472: Design Browser History</h3>
                </section>

                <section>
                    <h2>The Mutable Solution</h2>
                    <pre><code class="language-python">class BrowserHistoryMutable:
    """Works for interviews, breaks in production"""
    
    def __init__(self, homepage: str):
        self.history = [homepage]
        self.current = 0
    
    def visit(self, url: str):
        # MUTATION: destroy forward history forever!
        self.history = self.history[:self.current + 1]
        self.history.append(url)
        self.current += 1
    
    def back(self, steps: int) -> str:
        self.current = max(0, self.current - steps)
        return self.history[self.current]</code></pre>
                    <p class="fragment warning-box">
                        <strong>Problems:</strong> Forward history destroyed, race conditions, no branching, debugging impossible
                    </p>
                </section>

                <section>
                    <h2>The Immutable Mindset Shift</h2>
                    <div class="comparison-grid">
                        <div class="comparison-box bad">
                            <h3>Mutable World</h3>
                            <pre><code class="language-python">x = [1, 2, 3]
x.append(4)
# x is now [1, 2, 3, 4]
# Old value LOST forever!

# Undo = ???</code></pre>
                        </div>
                        <div class="comparison-box good">
                            <h3>Immutable World</h3>
                            <pre><code class="language-python">x = [1, 2, 3]
y = x + [4]
# x is STILL [1, 2, 3]
# y is [1, 2, 3, 4]
# Both versions exist!

# Undo = just use x!</code></pre>
                        </div>
                    </div>
                    <p class="fragment" style="color: var(--success); font-size: 1.2em;">
                        If values never change, undo is trivial‚Äîjust point to the old version.
                    </p>
                </section>
            </section>

            <!-- Act 3: Structural Sharing -->
            <section>
                <section>
                    <h2>Act 3: Structural Sharing</h2>
                    <h3>The Breakthrough That Makes It Efficient</h3>
                </section>

                <section>
                    <h2>Naive Immutability Fails</h2>
                    <pre><code class="language-python"># Naive immutable approach:
document = "..." # 100MB of text

v1 = document                      # 100MB
v2 = v1 + "a"                      # 100MB copy!
v3 = v2 + "b"                      # 100MB copy!
v4 = v3 + "c"                      # 100MB copy!

# After 1000 edits: 100GB of memory!
# This is WORSE than mutable!</code></pre>
                    <p class="fragment warning-box">
                        We need something smarter...
                    </p>
                </section>

                <section>
                    <h2>Structural Sharing ‚Äî The Key</h2>
                    <div class="animation-container">
                        <canvas id="structuralSharingCanvas" width="750" height="380"></canvas>
                    </div>
                    <p style="font-size: 0.8em; opacity: 0.8;">Click canvas to animate insert operation</p>
                </section>

                <section>
                    <h2>How Structural Sharing Works</h2>
                    <pre><code class="language-python">@dataclass(frozen=True)  # frozen = immutable!
class Leaf(TextNode):
    """Stores actual text."""
    text: str

@dataclass(frozen=True)
class Branch(TextNode):
    """Combines two subtrees - can share children!"""
    left: TextNode   # Reference to existing node
    right: TextNode  # Reference to existing node
    _length: int

# Insert "X" at position 5:
# - Only nodes on the PATH change
# - All other nodes are SHARED between versions</code></pre>
                </section>

                <section>
                    <h2>Memory Comparison</h2>
                    <div class="comparison-grid">
                        <div class="comparison-box bad">
                            <h3>Naive Copy</h3>
                            <p>100MB doc, 1000 edits</p>
                            <p>Each edit: 100MB copy</p>
                            <p class="stat-number" style="color: var(--danger);">100GB</p>
                            <p>Minutes (GC overwhelmed)</p>
                        </div>
                        <div class="comparison-box good">
                            <h3>Structural Sharing</h3>
                            <p>100MB doc, 1000 edits</p>
                            <p>Each edit: ~25 nodes (~3KB)</p>
                            <p class="stat-number" style="color: var(--success);">103MB</p>
                            <p>Microseconds per edit</p>
                        </div>
                    </div>
                    <p class="fragment" style="color: var(--success); font-size: 1.5em; margin-top: 20px;">
                        1000√ó less memory!
                    </p>
                </section>
            </section>

            <!-- Act 4: Persistent History DAG -->
            <section>
                <section>
                    <h2>Act 4: Persistent History DAG</h2>
                    <h3>Branching Undo with Parent/Child Pointers</h3>
                </section>

                <section>
                    <h2>History as a Graph</h2>
                    <div class="animation-container">
                        <canvas id="historyDagCanvas" width="750" height="380"></canvas>
                    </div>
                    <p style="font-size: 0.8em; opacity: 0.8;">Click to see branching undo in action</p>
                </section>

                <section>
                    <h2>History Node Structure</h2>
                    <pre><code class="language-python">@dataclass
class HistoryNode:
    """Node in the history DAG."""
    
    version_id: str        # Content-addressable hash (like Git!)
    text: ImmutableText    # The document state
    parent: Optional[str]  # Parent version (for undo)
    timestamp: float       # When created
    operation: str         # "insert(5, 'X')" - what created this
    children: Set[str]     # Child versions (for branching redo)
    
    def __init__(self, text, parent, operation):
        # Content-addressable ID (like Git!)
        content = f"{text.get_text()}:{parent}:{operation}"
        self.version_id = hashlib.sha256(content.encode()).hexdigest()[:16]</code></pre>
                </section>

                <section>
                    <h2>Branching Undo in Action</h2>
                    <pre><code class="language-python">history = PersistentHistory()
history.initialize("")

history.insert(0, "Hello")      # v1: "Hello"
history.insert(5, " World")     # v2: "Hello World"

# User realizes mistake, undoes
history.undo()                  # Back to v1: "Hello"

# User types something different
history.insert(5, "!")          # v3: "Hello!" (NEW BRANCH!)

# History DAG:
#     v0 ""
#      ‚îÇ
#     v1 "Hello"
#      ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
#     v2        v3
# "Hello World" "Hello!"</code></pre>
                    <p class="fragment success-box">
                        Both branches preserved! User can switch between them.
                    </p>
                </section>

                <section>
                    <h2>Redo with Multiple Branches</h2>
                    <pre><code class="language-python">def redo(self) -> Optional[str]:
    """Redo - but which branch?"""
    current = self.versions[self.current_version]
    
    if len(current.children) == 1:
        # Only one option - take it
        self.current_version = list(current.children)[0]
    else:
        # Multiple branches! Options:
        # 1. Pick most recent (default)
        # 2. Show user a branch picker UI
        # 3. Remember their previous choice
        
        children = [self.versions[cid] for cid in current.children]
        next_version = max(children, key=lambda n: n.timestamp)
        self.current_version = next_version.version_id
    
    return self.current_version</code></pre>
                </section>
            </section>

            <!-- Act 5: CRDTs -->
            <section>
                <section>
                    <h2>Act 5: CRDTs for Collaboration</h2>
                    <h3>Distributed Undo Across 50 Users</h3>
                </section>

                <section>
                    <h2>The Collaboration Challenge</h2>
                    <div class="animation-container">
                        <canvas id="crdtCanvas" width="750" height="380"></canvas>
                    </div>
                    <p style="font-size: 0.8em; opacity: 0.8;">Click to simulate concurrent edits</p>
                </section>

                <section>
                    <h2>Vector Clocks ‚Äî Tracking Causality</h2>
                    <pre><code class="language-python">@dataclass
class VectorClock:
    """Track causality across replicas."""
    clocks: Dict[str, int]  # replica_id ‚Üí timestamp
    
    def happens_before(self, other: 'VectorClock') -> bool:
        """Does self causally precede other?"""
        for replica_id, ts in self.clocks.items():
            if ts > other.clocks.get(replica_id, 0):
                return False
        return any(self.clocks.get(r, 0) < other.clocks.get(r, 0) 
                   for r in other.clocks)
    
    def concurrent_with(self, other: 'VectorClock') -> bool:
        """Are operations concurrent (conflict)?"""
        return not self.happens_before(other) and \
               not other.happens_before(self)</code></pre>
                </section>

                <section>
                    <h2>Operational Transformation</h2>
                    <pre><code class="language-python">def transform_position(self, op: CRDTOperation) -> int:
    """Adjust position based on concurrent operations."""
    adjusted_pos = op.position
    
    for logged_op in self.operation_log:
        if logged_op.vector_clock.concurrent_with(op.vector_clock):
            # Concurrent! Must transform.
            if logged_op.op_type == 'insert' and \
               logged_op.position <= op.position:
                # Their insert was before our position
                adjusted_pos += len(logged_op.content)
            
            elif logged_op.op_type == 'delete' and \
                 logged_op.position < op.position:
                # Their delete was before our position
                adjusted_pos -= len(logged_op.content)
    
    return max(0, adjusted_pos)</code></pre>
                </section>

                <section>
                    <h2>CRDT Undo = Tombstoning</h2>
                    <div class="highlight-box">
                        <p><strong>Alice undoes Bob's edit:</strong></p>
                        <p>1. Alice adds Bob's op_id to tombstones set</p>
                        <p>2. Tombstone broadcasts to all replicas</p>
                        <p>3. Each replica rebuilds, skipping tombstoned ops</p>
                        <p>4. All replicas converge to same state!</p>
                    </div>
                    <pre><code class="language-python">def undo_operation(self, op_id: str):
    """Undo works across replicas!"""
    self.tombstones.add(op_id)  # CRDT-safe!
    
    # Rebuild without tombstoned operations
    self._rebuild_document()</code></pre>
                    <p class="fragment success-box">
                        Tombstones are commutative, idempotent, and conflict-free!
                    </p>
                </section>

                <section>
                    <h2>Convergence Guarantee</h2>
                    <pre><code class="language-text">Initial: "Hello" (all replicas)

Alice: insert "X" at 5 (op_A)
Bob:   insert "Y" at 5 (op_B)  
Carol: delete 0-2     (op_C)

After all operations delivered:

Replica A: applies op_A, receives op_B, op_C
Replica B: applies op_B, receives op_A, op_C  
Replica C: applies op_C, receives op_A, op_B

Transformation ensures ALL replicas reach: "lloXY"

Alice undoes op_A:
‚îú‚îÄ‚îÄ Tombstone {op_A} propagates
‚îú‚îÄ‚îÄ All replicas rebuild without op_A
‚îî‚îÄ‚îÄ All replicas converge to: "lloY" ‚úì</code></pre>
                </section>
            </section>

            <!-- Act 6: Production Optimizations -->
            <section>
                <section>
                    <h2>Act 6: Production Optimizations</h2>
                    <h3>Garbage Collection & Delta Compression</h3>
                </section>

                <section>
                    <h2>The Memory Problem Returns</h2>
                    <pre><code class="language-text">User edits for 8 hours:
‚îú‚îÄ‚îÄ 10 edits per minute
‚îú‚îÄ‚îÄ 4,800 versions
‚îú‚îÄ‚îÄ Each version: 3KB (structural sharing)
‚îú‚îÄ‚îÄ Total: 14.4MB ‚Äî manageable!

But Google Docs at scale:
‚îú‚îÄ‚îÄ 1 billion documents
‚îú‚îÄ‚îÄ 5,000 versions each (average)
‚îú‚îÄ‚îÄ = 5 trillion history nodes
‚îî‚îÄ‚îÄ üí• Petabytes of storage!</code></pre>
                    <p class="fragment warning-box">
                        We need: <strong>GENERATIONAL GARBAGE COLLECTION</strong>
                    </p>
                </section>

                <section>
                    <h2>Generational History</h2>
                    <div class="animation-container">
                        <canvas id="gcCanvas" width="750" height="380"></canvas>
                    </div>
                    <p style="font-size: 0.8em; opacity: 0.8;">Click to see GC in action</p>
                </section>

                <section>
                    <h2>Delta Compression Strategy</h2>
                    <pre><code class="language-text">Every 100 versions:
‚îú‚îÄ‚îÄ Store FULL SNAPSHOT (compressed)
‚îú‚îÄ‚îÄ Store DELTAS for next 99 versions
‚îî‚îÄ‚îÄ Deltas are tiny!

Version 0:   [SNAPSHOT] "Hello World..." (10KB compressed)
Version 1:   [DELTA] insert(5, "X")      (50 bytes)
Version 2:   [DELTA] delete(3, 5)        (30 bytes)
...
Version 99:  [DELTA] insert(100, "Y")    (50 bytes)
Version 100: [SNAPSHOT] "..."            (10KB compressed)

Storage: 10KB + 99√ó50B + 10KB = 25KB
Naive:   100 √ó 10KB = 1MB

COMPRESSION: 40√ó!</code></pre>
                </section>

                <section>
                    <h2>Garbage Collection Code</h2>
                    <pre><code class="language-python">def garbage_collect(self):
    """Remove cold generations exceeding budget."""
    total_size = sum(g.size_bytes for g in self.generations)
    
    if total_size <= self.max_memory_bytes:
        return  # Under budget
    
    # Find cold generations (not recently accessed)
    cold = [g for g in self.generations 
            if g.snapshot_version not in self.hot_versions]
    
    cold.sort(key=lambda g: g.created_at)  # Oldest first
    
    while total_size > self.max_memory_bytes and cold:
        oldest = cold.pop(0)
        self.generations.remove(oldest)
        total_size -= oldest.size_bytes
        
        logging.info(f"GC: Freed {oldest.size_bytes} bytes")</code></pre>
                </section>
            </section>

            <!-- Act 7: When Immutability Breaks -->
            <section>
                <section>
                    <h2>Act 7: When NOT to Use Immutability</h2>
                    <h3>Engineering Judgment</h3>
                </section>

                <section>
                    <h2>When Immutability Fails</h2>
                    <table>
                        <tr>
                            <th>Scenario</th>
                            <th>Why It Fails</th>
                            <th>Use Instead</th>
                        </tr>
                        <tr>
                            <td>High-frequency mutations</td>
                            <td>O(log n) copies 1M/sec = GC pressure</td>
                            <td>Mutable + COW</td>
                        </tr>
                        <tr>
                            <td>Memory-constrained</td>
                            <td>Sharing still uses more memory</td>
                            <td>Mutable + checkpoints</td>
                        </tr>
                        <tr>
                            <td>Cache-hostile</td>
                            <td>Tree traversal = cache misses</td>
                            <td>Flat arrays</td>
                        </tr>
                        <tr>
                            <td>Write-heavy</td>
                            <td>Optimized for many readers</td>
                            <td>Fine-grained locks</td>
                        </tr>
                        <tr>
                            <td>Real-time systems</td>
                            <td>GC pauses break latency</td>
                            <td>Pre-allocated pools</td>
                        </tr>
                    </table>
                </section>

                <section>
                    <h2>The GC Pressure Problem</h2>
                    <pre><code class="language-python"># High-frequency edits:
for i in range(1_000_000):
    document = document.insert(i, "x")
    # Each iteration: ~25 new nodes
    # Old nodes become garbage
    # GC runs every ~1000 iterations

# Impact:
# ‚îú‚îÄ‚îÄ 25M allocations
# ‚îú‚îÄ‚îÄ GC pause every ~1000 iterations
# ‚îú‚îÄ‚îÄ Each pause: 10-100ms
# ‚îî‚îÄ‚îÄ Total GC time: 10-100 seconds!

# For games or trading systems: UNACCEPTABLE</code></pre>
                </section>

                <section>
                    <h2>When Immutability WINS</h2>
                    <div class="success-box">
                        <p>‚úÖ <strong>Collaborative editing</strong> ‚Äî Google Docs, Figma, Notion</p>
                        <p>‚úÖ <strong>Version control</strong> ‚Äî Git, Mercurial</p>
                        <p>‚úÖ <strong>State management</strong> ‚Äî Redux, Recoil, MobX</p>
                        <p>‚úÖ <strong>Distributed consensus</strong> ‚Äî CRDTs, Raft</p>
                        <p>‚úÖ <strong>Time-travel debugging</strong> ‚Äî Redux DevTools, rr</p>
                        <p>‚úÖ <strong>Database snapshots</strong> ‚Äî MVCC in PostgreSQL</p>
                    </div>
                </section>
            </section>

            <!-- Epilogue -->
            <section>
                <section>
                    <h2>Epilogue: Time Travel Debugging</h2>
                    <h3>The Ultimate Application</h3>
                </section>

                <section>
                    <h2>Record Execution as Immutable History</h2>
                    <pre><code class="language-python">class TimeTravelDebugger:
    """Record execution for replay."""
    
    def __init__(self):
        self.frames: List[ExecutionFrame] = []
    
    def replay_to_frame(self, index: int) -> ExecutionFrame:
        """Jump to ANY point in execution!"""
        return self.frames[index]  # O(1)!

# Usage:
debugger = TimeTravelDebugger()
debugger.start_recording()

result = fibonacci(10)  # Record everything

debugger.stop_recording()

# Jump to frame 50, inspect state
frame = debugger.replay_to_frame(50)
print(f"At frame 50: n={frame.local_vars['n']}")</code></pre>
                    <p class="fragment highlight-box">
                        This is exactly how <strong>Redux DevTools</strong> works!
                    </p>
                </section>

                <section>
                    <h2>Production Systems Using Immutability</h2>
                    <div class="two-column">
                        <div>
                            <h3>Redux (Facebook)</h3>
                            <p>Every action ‚Üí new state</p>
                            <p>Time-travel debugging</p>
                            <p><span class="badge badge-blue">5M+ apps</span></p>
                        </div>
                        <div>
                            <h3>Git</h3>
                            <p>Commits are immutable</p>
                            <p>Content-addressable</p>
                            <p><span class="badge badge-green">100M+ developers</span></p>
                        </div>
                    </div>
                    <div class="two-column" style="margin-top: 30px;">
                        <div>
                            <h3>Figma</h3>
                            <p>CRDT-based collaboration</p>
                            <p>Branching undo</p>
                            <p><span class="badge badge-yellow">4M+ users</span></p>
                        </div>
                        <div>
                            <h3>Datomic</h3>
                            <p>Immutable facts over time</p>
                            <p>Time-travel queries</p>
                            <p><span class="badge badge-blue">Nubank (50M customers)</span></p>
                        </div>
                    </div>
                </section>

                <section>
                    <h2>Key Takeaways</h2>
                    <div class="highlight-box">
                        <p>1. <strong>Mutation makes correctness hard</strong> ‚Äî race conditions, lost history</p>
                        <p>2. <strong>Immutability enables time travel</strong> ‚Äî every version preserved</p>
                        <p>3. <strong>Structural sharing makes it efficient</strong> ‚Äî O(log n) copies</p>
                        <p>4. <strong>DAGs enable branching history</strong> ‚Äî undo, redo, branch, merge</p>
                        <p>5. <strong>CRDTs enable distributed undo</strong> ‚Äî eventual consistency</p>
                        <p>6. <strong>Know when NOT to use it</strong> ‚Äî high-frequency, real-time</p>
                    </div>
                </section>

                <section>
                    <h2>Next Episode: LRU Caches at Scale</h2>
                    <blockquote>
                        "What happens when your immutable history grows to 100GB? How do you decide what to keep and what to evict?"
                    </blockquote>
                    <div class="highlight-box">
                        <p>Challenge: 100,000 requests/sec with &lt;1ms p99 latency</p>
                        <p>O(1) get/put/evict using doubly-linked lists + hashmaps</p>
                        <p>Zero heap allocations in hot path</p>
                        <p>No lock contention between reader threads</p>
                    </div>
                    <p style="font-size: 1.5em; margin-top: 30px;">See you in Episode 5! üöÄ</p>
                </section>
            </section>

        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.5.0/reveal.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.5.0/plugin/highlight/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.5.0/plugin/notes/notes.min.js"></script>
    <script>
        // Initialize Reveal.js
        Reveal.initialize({
            hash: true,
            slideNumber: 'c/t',
            plugins: [RevealHighlight, RevealNotes],
            transition: 'slide',
            backgroundTransition: 'fade'
        });

        // Polyfill for roundRect
        if (!CanvasRenderingContext2D.prototype.roundRect) {
            CanvasRenderingContext2D.prototype.roundRect = function(x, y, w, h, r) {
                if (w < 2 * r) r = w / 2;
                if (h < 2 * r) r = h / 2;
                this.beginPath();
                this.moveTo(x + r, y);
                this.arcTo(x + w, y, x + w, y + h, r);
                this.arcTo(x + w, y + h, x, y + h, r);
                this.arcTo(x, y + h, x, y, r);
                this.arcTo(x, y, x + w, y, r);
                this.closePath();
                return this;
            };
        }

        // ==========================================
        // Animation 1: Structural Sharing
        // ==========================================
        const structuralSharingAnim = {
            canvas: null,
            ctx: null,
            state: 0,
            nodes: [],
            
            init() {
                this.canvas = document.getElementById('structuralSharingCanvas');
                if (!this.canvas) return;
                this.ctx = this.canvas.getContext('2d');
                this.state = 0;
                this.draw();
                
                this.canvas.addEventListener('click', () => {
                    this.state = (this.state + 1) % 3;
                    this.draw();
                });
            },
            
            draw() {
                const ctx = this.ctx;
                const W = this.canvas.width;
                const H = this.canvas.height;
                
                ctx.clearRect(0, 0, W, H);
                
                // Draw title based on state
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 18px Segoe UI';
                ctx.textAlign = 'center';
                
                const titles = [
                    'Original Tree (100MB document)',
                    'Insert "X" at position 5 ‚Äî Only path nodes change!',
                    'Both versions coexist ‚Äî Shared nodes highlighted'
                ];
                ctx.fillText(titles[this.state], W/2, 30);
                
                // Draw trees
                if (this.state === 0) {
                    this.drawTree(ctx, W/2, 80, 'original');
                } else if (this.state === 1) {
                    this.drawTree(ctx, W/4, 80, 'original', 0.5);
                    this.drawTree(ctx, 3*W/4, 80, 'new');
                    
                    // Arrow
                    ctx.strokeStyle = '#4facfe';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(W/2 - 50, H/2);
                    ctx.lineTo(W/2 + 50, H/2);
                    ctx.stroke();
                    ctx.fillStyle = '#4facfe';
                    ctx.beginPath();
                    ctx.moveTo(W/2 + 50, H/2);
                    ctx.lineTo(W/2 + 35, H/2 - 10);
                    ctx.lineTo(W/2 + 35, H/2 + 10);
                    ctx.fill();
                } else {
                    this.drawTree(ctx, W/4, 80, 'original', 0.5);
                    this.drawTree(ctx, 3*W/4, 80, 'shared');
                    
                    // Memory comparison
                    ctx.fillStyle = '#fff';
                    ctx.font = '14px Segoe UI';
                    ctx.fillText('Naive copy: 100MB', W/4, H - 40);
                    ctx.fillStyle = '#00b894';
                    ctx.fillText('Structural sharing: ~3KB (25 nodes)', 3*W/4, H - 40);
                }
            },
            
            drawTree(ctx, centerX, topY, type, alpha = 1) {
                ctx.globalAlpha = alpha;
                
                const nodeColors = {
                    original: '#4facfe',
                    new: '#00b894',
                    shared: '#00f2fe'
                };
                
                const levels = [
                    [{label: 'Root', new: type === 'new' || type === 'shared'}],
                    [{label: 'A', new: false}, {label: 'B', new: type === 'new' || type === 'shared'}],
                    [{label: '1', new: false}, {label: '2', new: false}, {label: '3', new: type === 'new' || type === 'shared'}, {label: '4', new: false}]
                ];
                
                const nodeWidth = 50;
                const nodeHeight = 30;
                const levelGap = 80;
                
                levels.forEach((level, li) => {
                    const levelWidth = level.length * 80;
                    const startX = centerX - levelWidth/2 + 40;
                    
                    level.forEach((node, ni) => {
                        const x = startX + ni * 80;
                        const y = topY + li * levelGap;
                        
                        // Draw connection to parent
                        if (li > 0) {
                            const parentLevel = levels[li - 1];
                            const parentIdx = Math.floor(ni / 2);
                            const parentX = centerX - (parentLevel.length * 80)/2 + 40 + parentIdx * 80;
                            const parentY = topY + (li - 1) * levelGap + nodeHeight;
                            
                            ctx.strokeStyle = node.new && type !== 'original' ? '#00b894' : '#4facfe';
                            ctx.lineWidth = 2;
                            ctx.beginPath();
                            ctx.moveTo(parentX, parentY);
                            ctx.lineTo(x, y);
                            ctx.stroke();
                        }
                        
                        // Draw node
                        let color = nodeColors.original;
                        if (type === 'new' && node.new) color = nodeColors.new;
                        if (type === 'shared' && !node.new) color = nodeColors.shared;
                        if (type === 'shared' && node.new) color = nodeColors.new;
                        
                        ctx.fillStyle = color;
                        ctx.roundRect(x - nodeWidth/2, y, nodeWidth, nodeHeight, 8);
                        ctx.fill();
                        
                        ctx.fillStyle = '#000';
                        ctx.font = 'bold 14px Segoe UI';
                        ctx.textAlign = 'center';
                        ctx.fillText(node.label, x, y + 20);
                    });
                });
                
                ctx.globalAlpha = 1;
            }
        };

        // ==========================================
        // Animation 2: History DAG
        // ==========================================
        const historyDagAnim = {
            canvas: null,
            ctx: null,
            state: 0,
            
            init() {
                this.canvas = document.getElementById('historyDagCanvas');
                if (!this.canvas) return;
                this.ctx = this.canvas.getContext('2d');
                this.state = 0;
                this.draw();
                
                this.canvas.addEventListener('click', () => {
                    this.state = (this.state + 1) % 5;
                    this.draw();
                });
            },
            
            draw() {
                const ctx = this.ctx;
                const W = this.canvas.width;
                const H = this.canvas.height;
                
                ctx.clearRect(0, 0, W, H);
                
                const steps = [
                    {nodes: [{id: 'v0', text: '""', x: W/2, y: 50, current: true}], title: 'Initialize: empty document'},
                    {nodes: [
                        {id: 'v0', text: '""', x: W/2, y: 50, current: false},
                        {id: 'v1', text: '"Hello"', x: W/2, y: 130, current: true, parent: 'v0'}
                    ], title: 'Type "Hello"'},
                    {nodes: [
                        {id: 'v0', text: '""', x: W/2, y: 50, current: false},
                        {id: 'v1', text: '"Hello"', x: W/2, y: 130, current: false, parent: 'v0'},
                        {id: 'v2', text: '"Hello World"', x: W/2, y: 210, current: true, parent: 'v1'}
                    ], title: 'Type " World"'},
                    {nodes: [
                        {id: 'v0', text: '""', x: W/2, y: 50, current: false},
                        {id: 'v1', text: '"Hello"', x: W/2, y: 130, current: true, parent: 'v0'},
                        {id: 'v2', text: '"Hello World"', x: W/2, y: 210, current: false, parent: 'v1'}
                    ], title: 'UNDO ‚Üí back to "Hello"'},
                    {nodes: [
                        {id: 'v0', text: '""', x: W/2, y: 50, current: false},
                        {id: 'v1', text: '"Hello"', x: W/2, y: 130, current: false, parent: 'v0'},
                        {id: 'v2', text: '"Hello World"', x: W/2 - 100, y: 230, current: false, parent: 'v1'},
                        {id: 'v3', text: '"Hello!"', x: W/2 + 100, y: 230, current: true, parent: 'v1', isNew: true}
                    ], title: 'Type "!" ‚Üí NEW BRANCH! Both paths exist!'}
                ];
                
                const step = steps[this.state];
                
                // Title
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 18px Segoe UI';
                ctx.textAlign = 'center';
                ctx.fillText(step.title, W/2, 30);
                
                // Draw connections
                step.nodes.forEach(node => {
                    if (node.parent) {
                        const parent = step.nodes.find(n => n.id === node.parent);
                        if (parent) {
                            ctx.strokeStyle = node.isNew ? '#00b894' : '#4facfe';
                            ctx.lineWidth = 2;
                            ctx.beginPath();
                            ctx.moveTo(parent.x, parent.y + 30);
                            ctx.lineTo(node.x, node.y);
                            ctx.stroke();
                        }
                    }
                });
                
                // Draw nodes
                step.nodes.forEach(node => {
                    const width = Math.max(100, ctx.measureText(node.text).width + 40);
                    
                    // Node background
                    if (node.current) {
                        ctx.fillStyle = '#00b894';
                    } else if (node.isNew) {
                        ctx.fillStyle = '#f093fb';
                    } else {
                        ctx.fillStyle = '#4facfe';
                    }
                    ctx.roundRect(node.x - width/2, node.y, width, 35, 8);
                    ctx.fill();
                    
                    // Node text
                    ctx.fillStyle = '#000';
                    ctx.font = 'bold 14px Segoe UI';
                    ctx.textAlign = 'center';
                    ctx.fillText(`${node.id}: ${node.text}`, node.x, node.y + 22);
                    
                    // Current indicator
                    if (node.current) {
                        ctx.fillStyle = '#fff';
                        ctx.font = '12px Segoe UI';
                        ctx.fillText('‚Üê current', node.x + width/2 + 40, node.y + 22);
                    }
                });
                
                // Instructions
                ctx.fillStyle = 'rgba(255,255,255,0.6)';
                ctx.font = '12px Segoe UI';
                ctx.fillText(`Step ${this.state + 1}/5 ‚Äî Click to continue`, W/2, H - 20);
            }
        };

        // ==========================================
        // Animation 3: CRDT Concurrent Edits
        // ==========================================
        const crdtAnim = {
            canvas: null,
            ctx: null,
            state: 0,
            
            init() {
                this.canvas = document.getElementById('crdtCanvas');
                if (!this.canvas) return;
                this.ctx = this.canvas.getContext('2d');
                this.state = 0;
                this.draw();
                
                this.canvas.addEventListener('click', () => {
                    this.state = (this.state + 1) % 5;
                    this.draw();
                });
            },
            
            draw() {
                const ctx = this.ctx;
                const W = this.canvas.width;
                const H = this.canvas.height;
                
                ctx.clearRect(0, 0, W, H);
                
                const aliceX = 150;
                const bobX = W - 150;
                
                // Draw Alice and Bob labels
                ctx.fillStyle = '#4facfe';
                ctx.font = 'bold 16px Segoe UI';
                ctx.textAlign = 'center';
                ctx.fillText('Alice (NYC)', aliceX, 30);
                
                ctx.fillStyle = '#f093fb';
                ctx.fillText('Bob (London)', bobX, 30);
                
                // Draw timeline
                ctx.strokeStyle = 'rgba(255,255,255,0.3)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(aliceX, 50);
                ctx.lineTo(aliceX, H - 60);
                ctx.stroke();
                
                ctx.beginPath();
                ctx.moveTo(bobX, 50);
                ctx.lineTo(bobX, H - 60);
                ctx.stroke();
                
                const scenarios = [
                    {
                        title: 'Both start with "Hello"',
                        alice: [{y: 80, text: '"Hello"', type: 'state'}],
                        bob: [{y: 80, text: '"Hello"', type: 'state'}]
                    },
                    {
                        title: 'Alice inserts "X" at pos 5',
                        alice: [
                            {y: 80, text: '"Hello"', type: 'state'},
                            {y: 140, text: 'insert("X", 5)', type: 'op'},
                            {y: 180, text: '"HelloX"', type: 'state'}
                        ],
                        bob: [{y: 80, text: '"Hello"', type: 'state'}]
                    },
                    {
                        title: 'Bob inserts "Y" at pos 5 (concurrent!)',
                        alice: [
                            {y: 80, text: '"Hello"', type: 'state'},
                            {y: 140, text: 'insert("X", 5)', type: 'op'},
                            {y: 180, text: '"HelloX"', type: 'state'}
                        ],
                        bob: [
                            {y: 80, text: '"Hello"', type: 'state'},
                            {y: 140, text: 'insert("Y", 5)', type: 'op'},
                            {y: 180, text: '"HelloY"', type: 'state'}
                        ],
                        arrows: [
                            {from: 'alice', to: 'bob', y1: 150, y2: 220, label: 'op_A'},
                            {from: 'bob', to: 'alice', y1: 150, y2: 220, label: 'op_B'}
                        ]
                    },
                    {
                        title: 'Operations cross in transit ‚Äî CONFLICT!',
                        alice: [
                            {y: 80, text: '"HelloX"', type: 'state'},
                            {y: 140, text: 'receive op_B', type: 'op'},
                            {y: 180, text: 'transform(5 ‚Üí 6)', type: 'transform'}
                        ],
                        bob: [
                            {y: 80, text: '"HelloY"', type: 'state'},
                            {y: 140, text: 'receive op_A', type: 'op'},
                            {y: 180, text: 'transform(5 ‚Üí 5)', type: 'transform'}
                        ]
                    },
                    {
                        title: 'Both converge to "HelloXY" ‚úì',
                        alice: [
                            {y: 100, text: '"HelloXY"', type: 'success'}
                        ],
                        bob: [
                            {y: 100, text: '"HelloXY"', type: 'success'}
                        ],
                        converged: true
                    }
                ];
                
                const scenario = scenarios[this.state];
                
                // Title
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 18px Segoe UI';
                ctx.textAlign = 'center';
                ctx.fillText(scenario.title, W/2, H - 30);
                
                // Draw Alice's events
                scenario.alice.forEach(event => {
                    this.drawEvent(ctx, aliceX, event, '#4facfe');
                });
                
                // Draw Bob's events
                scenario.bob.forEach(event => {
                    this.drawEvent(ctx, bobX, event, '#f093fb');
                });
                
                // Draw arrows
                if (scenario.arrows) {
                    scenario.arrows.forEach(arrow => {
                        const fromX = arrow.from === 'alice' ? aliceX : bobX;
                        const toX = arrow.to === 'alice' ? aliceX : bobX;
                        
                        ctx.strokeStyle = '#ffeaa7';
                        ctx.lineWidth = 2;
                        ctx.setLineDash([5, 5]);
                        ctx.beginPath();
                        ctx.moveTo(fromX, arrow.y1);
                        ctx.lineTo(toX, arrow.y2);
                        ctx.stroke();
                        ctx.setLineDash([]);
                        
                        // Label
                        ctx.fillStyle = '#ffeaa7';
                        ctx.font = '12px Segoe UI';
                        ctx.fillText(arrow.label, (fromX + toX)/2, (arrow.y1 + arrow.y2)/2 - 5);
                    });
                }
                
                // Convergence indicator
                if (scenario.converged) {
                    ctx.strokeStyle = '#00b894';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(aliceX + 80, 100);
                    ctx.lineTo(bobX - 80, 100);
                    ctx.stroke();
                    
                    ctx.fillStyle = '#00b894';
                    ctx.font = 'bold 14px Segoe UI';
                    ctx.fillText('CONVERGED!', W/2, 130);
                }
                
                // Step indicator
                ctx.fillStyle = 'rgba(255,255,255,0.6)';
                ctx.font = '12px Segoe UI';
                ctx.fillText(`Step ${this.state + 1}/5`, W/2, H - 10);
            },
            
            drawEvent(ctx, x, event, color) {
                ctx.font = '13px Segoe UI';
                ctx.textAlign = 'center';
                
                if (event.type === 'state') {
                    ctx.fillStyle = color;
                    ctx.roundRect(x - 50, event.y, 100, 30, 6);
                    ctx.fill();
                    ctx.fillStyle = '#000';
                    ctx.fillText(event.text, x, event.y + 20);
                } else if (event.type === 'op') {
                    ctx.fillStyle = 'rgba(255,255,255,0.1)';
                    ctx.roundRect(x - 60, event.y, 120, 25, 6);
                    ctx.fill();
                    ctx.fillStyle = '#fff';
                    ctx.font = '11px monospace';
                    ctx.fillText(event.text, x, event.y + 17);
                } else if (event.type === 'transform') {
                    ctx.fillStyle = '#ffeaa7';
                    ctx.font = '11px Segoe UI';
                    ctx.fillText(event.text, x, event.y + 15);
                } else if (event.type === 'success') {
                    ctx.fillStyle = '#00b894';
                    ctx.roundRect(x - 60, event.y, 120, 40, 8);
                    ctx.fill();
                    ctx.fillStyle = '#000';
                    ctx.font = 'bold 14px Segoe UI';
                    ctx.fillText(event.text, x, event.y + 26);
                }
            }
        };

        // ==========================================
        // Animation 4: Garbage Collection
        // ==========================================
        const gcAnim = {
            canvas: null,
            ctx: null,
            state: 0,
            
            init() {
                this.canvas = document.getElementById('gcCanvas');
                if (!this.canvas) return;
                this.ctx = this.canvas.getContext('2d');
                this.state = 0;
                this.draw();
                
                this.canvas.addEventListener('click', () => {
                    this.state = (this.state + 1) % 4;
                    this.draw();
                });
            },
            
            draw() {
                const ctx = this.ctx;
                const W = this.canvas.width;
                const H = this.canvas.height;
                
                ctx.clearRect(0, 0, W, H);
                
                const titles = [
                    'Versions accumulate over time',
                    'HOT tier: Recent versions (uncompressed)',
                    'COLD tier: Old versions (compressed to deltas)',
                    'GC: Evict coldest when over budget'
                ];
                
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 18px Segoe UI';
                ctx.textAlign = 'center';
                ctx.fillText(titles[this.state], W/2, 30);
                
                // Draw memory budget bar
                ctx.fillStyle = 'rgba(255,255,255,0.1)';
                ctx.roundRect(50, 60, W - 100, 30, 8);
                ctx.fill();
                
                const usages = [0.3, 0.5, 0.8, 0.6];
                const usage = usages[this.state];
                
                ctx.fillStyle = usage > 0.7 ? '#ff6b6b' : '#00b894';
                ctx.roundRect(50, 60, (W - 100) * usage, 30, 8);
                ctx.fill();
                
                ctx.fillStyle = '#fff';
                ctx.font = '12px Segoe UI';
                ctx.textAlign = 'right';
                ctx.fillText(`${Math.round(usage * 100)}% of 100MB budget`, W - 60, 80);
                
                // Draw version boxes
                const versions = [
                    {id: 'v1', age: 'old', size: '10KB'},
                    {id: 'v2', age: 'old', size: '8KB'},
                    {id: 'v3', age: 'medium', size: '12KB'},
                    {id: 'v4', age: 'medium', size: '9KB'},
                    {id: 'v5', age: 'recent', size: '15KB'},
                    {id: 'v6', age: 'recent', size: '11KB'},
                    {id: 'v7', age: 'hot', size: '3KB'},
                    {id: 'v8', age: 'hot', size: '3KB'}
                ];
                
                const boxWidth = 80;
                const boxHeight = 60;
                const startX = (W - versions.length * (boxWidth + 10)) / 2;
                
                versions.forEach((v, i) => {
                    const x = startX + i * (boxWidth + 10);
                    const y = 120;
                    
                    let color, label;
                    let isEvicted = false;
                    let isCompressed = false;
                    
                    if (this.state === 0) {
                        color = '#4facfe';
                        label = 'Full';
                    } else if (this.state === 1) {
                        if (v.age === 'hot' || v.age === 'recent') {
                            color = '#00b894';
                            label = 'HOT';
                        } else {
                            color = '#4facfe';
                            label = 'Full';
                        }
                    } else if (this.state === 2) {
                        if (v.age === 'hot' || v.age === 'recent') {
                            color = '#00b894';
                            label = 'HOT';
                        } else {
                            color = '#f093fb';
                            label = 'COLD';
                            isCompressed = true;
                        }
                    } else {
                        if (v.age === 'old') {
                            isEvicted = true;
                        } else if (v.age === 'hot' || v.age === 'recent') {
                            color = '#00b894';
                            label = 'HOT';
                        } else {
                            color = '#f093fb';
                            label = 'COLD';
                            isCompressed = true;
                        }
                    }
                    
                    if (isEvicted) {
                        ctx.strokeStyle = '#ff6b6b';
                        ctx.lineWidth = 2;
                        ctx.setLineDash([5, 5]);
                        ctx.strokeRect(x, y, boxWidth, boxHeight);
                        ctx.setLineDash([]);
                        
                        ctx.fillStyle = 'rgba(255,107,107,0.3)';
                        ctx.fillRect(x, y, boxWidth, boxHeight);
                        
                        // X mark
                        ctx.strokeStyle = '#ff6b6b';
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.moveTo(x + 10, y + 10);
                        ctx.lineTo(x + boxWidth - 10, y + boxHeight - 10);
                        ctx.moveTo(x + boxWidth - 10, y + 10);
                        ctx.lineTo(x + 10, y + boxHeight - 10);
                        ctx.stroke();
                        
                        ctx.fillStyle = '#ff6b6b';
                        ctx.font = '10px Segoe UI';
                        ctx.textAlign = 'center';
                        ctx.fillText('EVICTED', x + boxWidth/2, y + boxHeight + 15);
                    } else {
                        ctx.fillStyle = color;
                        ctx.roundRect(x, y, boxWidth, boxHeight, 8);
                        ctx.fill();
                        
                        ctx.fillStyle = '#000';
                        ctx.font = 'bold 14px Segoe UI';
                        ctx.textAlign = 'center';
                        ctx.fillText(v.id, x + boxWidth/2, y + 25);
                        
                        ctx.font = '11px Segoe UI';
                        ctx.fillText(isCompressed ? 'delta' : v.size, x + boxWidth/2, y + 42);
                        
                        ctx.fillStyle = '#fff';
                        ctx.font = '10px Segoe UI';
                        ctx.fillText(label, x + boxWidth/2, y + boxHeight + 15);
                    }
                });
                
                // Legend
                ctx.font = '12px Segoe UI';
                ctx.textAlign = 'left';
                
                const legendY = H - 80;
                
                ctx.fillStyle = '#00b894';
                ctx.fillRect(50, legendY, 15, 15);
                ctx.fillStyle = '#fff';
                ctx.fillText('HOT (uncompressed, fast)', 70, legendY + 12);
                
                ctx.fillStyle = '#f093fb';
                ctx.fillRect(250, legendY, 15, 15);
                ctx.fillStyle = '#fff';
                ctx.fillText('COLD (delta compressed)', 270, legendY + 12);
                
                ctx.fillStyle = '#ff6b6b';
                ctx.fillRect(470, legendY, 15, 15);
                ctx.fillStyle = '#fff';
                ctx.fillText('EVICTED (over budget)', 490, legendY + 12);
                
                // Instructions
                ctx.fillStyle = 'rgba(255,255,255,0.6)';
                ctx.font = '12px Segoe UI';
                ctx.textAlign = 'center';
                ctx.fillText(`Step ${this.state + 1}/4 ‚Äî Click to continue`, W/2, H - 20);
            }
        };

        // Initialize animations when slides become visible
        Reveal.on('slidechanged', event => {
            const slide = event.currentSlide;
            
            if (slide.querySelector('#structuralSharingCanvas')) {
                structuralSharingAnim.init();
            }
            if (slide.querySelector('#historyDagCanvas')) {
                historyDagAnim.init();
            }
            if (slide.querySelector('#crdtCanvas')) {
                crdtAnim.init();
            }
            if (slide.querySelector('#gcCanvas')) {
                gcAnim.init();
            }
        });

        // Initial setup for first visible canvases
        document.addEventListener('DOMContentLoaded', () => {
            setTimeout(() => {
                structuralSharingAnim.init();
                historyDagAnim.init();
                crdtAnim.init();
                gcAnim.init();
            }, 500);
        });
    </script>
</body>
</html>
