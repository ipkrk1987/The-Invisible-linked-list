<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Episode 2.1: Sorted Logs - When Binary Search Meets Persistence</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js/dist/reveal.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js/dist/theme/black.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js/plugin/highlight/monokai.css">
  <style>
    .reveal { 
      font-family: 'Segoe UI', 'Arial', sans-serif; 
      font-size: 28px !important;
    }
    .reveal .slides { font-size: 28px !important; }
    .reveal h1 { font-size: 1.8em !important; }
    .reveal h2 { font-size: 1.4em !important; }
    .reveal h3 { font-size: 1.15em !important; }
    .reveal h1, .reveal h2, .reveal h3 { text-transform: none; }
    
    /* Thesis and Framework Styles */
    .thesis-box {
      background: linear-gradient(135deg, rgba(245,158,66,0.9), rgba(245,87,108,0.9));
      border: 2px solid #f59e42;
      border-radius: 10px;
      margin: 12px auto;
      padding: 12px 18px;
      font-size: 0.85em;
      font-weight: bold;
      box-shadow: 0 4px 15px rgba(245,158,66,0.3);
      color: #fff;
      max-width: 98%;
      text-align: center;
    }
    
    .series-framework {
      background: rgba(79,172,254,0.15);
      border: 1px solid #4facfe;
      border-radius: 8px;
      margin: 10px auto;
      padding: 10px 15px;
      font-size: 0.75em;
      color: #4facfe;
      max-width: 98%;
      text-align: left;
    }
    
    /* Failure Mode Styles */
    .failure-mode {
      background: linear-gradient(135deg, rgba(239,68,68,0.9), rgba(245,87,108,0.9));
      border: 2px solid #ef4444;
      border-radius: 6px;
      margin: 10px auto;
      padding: 10px 14px;
      font-size: 0.7em;
      box-shadow: 0 3px 10px rgba(239,68,68,0.4);
      color: #fff;
      max-width: 98%;
      text-align: left;
      animation: pulseRed 2s infinite alternate;
    }
    
    @keyframes pulseRed {
      from { box-shadow: 0 6px 20px rgba(239,68,68,0.4); }
      to { box-shadow: 0 8px 30px rgba(239,68,68,0.7); }
    }
    
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }
    
    .pressure-point {
      background: rgba(255,255,100,0.2);
      border-left: 3px solid #facc15;
      padding: 6px 12px;
      margin: 6px 0;
      border-radius: 0 4px 4px 0;
      font-size: 0.75em;
    }
    
    .reality-check {
      background: rgba(245,158,66,0.2);
      border-left: 3px solid #f59e42;
      padding: 6px 12px;
      margin: 6px 0;
      border-radius: 0 4px 4px 0;
      font-size: 0.75em;
      font-style: italic;
    }
    
    /* Engineering Solution Styles */
    .engineering-solution {
      background: linear-gradient(135deg, rgba(34,197,94,0.9), rgba(79,172,254,0.9));
      border: 2px solid #22c55e;
      border-radius: 6px;
      margin: 10px auto;
      padding: 10px 14px;
      font-size: 0.7em;
      box-shadow: 0 3px 10px rgba(34,197,94,0.4);
      color: #fff;
      max-width: 98%;
      text-align: left;
    }
    
    /* Drama and Tension Styles */
    .perfect-storm {
      background: radial-gradient(circle, rgba(239,68,68,0.9), rgba(127,29,29,0.9));
      border: 3px solid #dc2626;
      border-radius: 15px;
      margin: 25px auto;
      padding: 25px 30px;
      font-size: 0.9em;
      box-shadow: 0 10px 40px rgba(239,68,68,0.6);
      color: #fff;
      max-width: 90%;
      text-align: center;
      animation: dramaticPulse 1.5s infinite alternate;
    }
    
    @keyframes dramaticPulse {
      from { 
        transform: scale(1);
        box-shadow: 0 10px 40px rgba(239,68,68,0.6);
      }
      to { 
        transform: scale(1.02);
        box-shadow: 0 15px 50px rgba(239,68,68,0.8);
      }
    }
    
    .doomed-text {
      color: #ef4444;
      font-weight: bold;
      font-style: italic;
      animation: fadeInRed 2s ease;
    }
    
    @keyframes fadeInRed {
      from { opacity: 0; color: #666; }
      to { opacity: 1; color: #ef4444; }
    }
    
    /* Stats and Comparisons */
    .comparison-dramatic {
      display: flex;
      gap: 12px;
      justify-content: center;
      margin: 12px 0;
      font-size: 0.65em;
    }
    
    .comparison-side {
      padding: 10px;
      border-radius: 6px;
      width: 48%;
      text-align: left;
    }
    
    .comparison-side.algorithm {
      background: rgba(79,172,254,0.2);
      border: 2px solid #4facfe;
    }
    
    .comparison-side.engineering {
      background: rgba(34,197,94,0.2);
      border: 2px solid #22c55e;
    }
    
    .comparison-side.broken {
      background: rgba(239,68,68,0.2);
      border: 2px solid #ef4444;
    }
    
    .feynman-diagram {
      background: rgba(236,254,255,0.95);
      border-left: 6px solid #06b6d4;
      border-radius: 10px;
      margin: 16px auto;
      padding: 14px 22px;
      font-size: 0.82em;
      box-shadow: 0 2px 12px 0 rgba(6,182,212,0.15);
      color: #0e3a4a;
      max-width: 85%;
      text-align: left;
    }
    
    .feynman-why {
      background: rgba(236,254,255,0.95);
      border-left: 6px solid #06b6d4;
      border-radius: 10px;
      margin: 16px auto;
      padding: 14px 22px;
      font-size: 0.82em;
      box-shadow: 0 2px 12px 0 rgba(6,182,212,0.15);
      color: #0e3a4a;
      max-width: 85%;
      text-align: left;
    }
    
    .scale-break {
      background: rgba(255,245,230,0.95);
      border-left: 6px solid #f59e42;
      border-radius: 10px;
      margin: 18px auto;
      padding: 16px 22px;
      font-size: 0.85em;
      box-shadow: 0 2px 12px 0 rgba(245,158,66,0.15);
      color: #7c4700;
      max-width: 85%;
      text-align: left;
    }
    
    .comparison {
      display: flex;
      gap: 10px;
      justify-content: center;
      margin: 10px 0;
      font-size: 0.65em;
    }
    
    .comparison-side.naive {
      background: rgba(255,100,100,0.15);
      border: 2px solid #f5576c;
    }
    
    .comparison-side.production {
      background: rgba(100,255,200,0.15);
      border: 2px solid #3ec6a8;
    }
    
    .comparison-title {
      font-weight: bold;
      margin-bottom: 12px;
      font-size: 1.1em;
    }
    
    .stats-row {
      display: flex;
      gap: 12px;
      justify-content: center;
      margin: 12px 0;
    }
    
    .stat-card {
      background: rgba(255,255,255,0.1);
      border-radius: 6px;
      padding: 8px 15px;
      text-align: center;
    }
    
    .stat-value {
      font-size: 1.4em;
      font-weight: bold;
      color: #4facfe;
    }
    
    .stat-label {
      font-size: 0.7em;
      opacity: 0.8;
    }
    
    .reveal pre {
      font-size: 0.75em;
      width: 98%;
      margin: 0 auto;
      line-height: 1.4;
    }
    
    .reveal pre code {
      max-height: 380px;
      overflow-y: auto;
      padding: 12px 15px;
      border-radius: 8px;
      font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
    }
    
    .act-intro {
      font-size: 0.75em;
      opacity: 0.9;
      max-width: 95%;
      margin: 0 auto;
      line-height: 1.5;
    }
    
    .act-title {
      text-align: center;
    }
    
    .act-title h1 {
      font-size: 2.5em !important;
      margin-bottom: 10px;
    }
    
    blockquote {
      font-style: italic;
      border-left: 4px solid #4facfe;
      padding-left: 20px;
      margin: 20px auto;
      max-width: 80%;
    }
    
    .dramatic-quote {
      font-style: italic;
      font-size: 1.1em;
      color: #f59e42;
      margin: 20px auto;
      padding: 15px;
      border: 1px solid rgba(245,158,66,0.3);
      border-radius: 8px;
      background: rgba(245,158,66,0.1);
    }
    
    /* Company badges */
    .company-badge {
      display: inline-block;
      padding: 4px 12px;
      border-radius: 4px;
      font-size: 0.7em;
      margin: 3px;
      font-weight: bold;
    }
    
    .company-badge.rocksdb {
      background: rgba(255,107,0,0.2);
      border: 1px solid #ff6b00;
      color: #ff6b00;
    }
    
    .company-badge.cassandra {
      background: rgba(26,188,156,0.2);
      border: 1px solid #1abc9c;
      color: #1abc9c;
    }
    
    .company-badge.bigtable {
      background: rgba(66,133,244,0.2);
      border: 1px solid #4285f4;
      color: #4285f4;
    }
    
    /* Leetcode badge */
    .leetcode-badge {
      background: linear-gradient(135deg, #ffa116, #ff6b00);
      padding: 6px 15px;
      border-radius: 6px;
      font-weight: bold;
      display: inline-block;
      margin: 8px 0;
      color: #fff;
    }
    
    /* Architecture diagram */
    .architecture-flow {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 15px;
      margin: 20px 0;
      flex-wrap: wrap;
    }
    
    .arch-box {
      background: rgba(79,172,254,0.2);
      border: 2px solid #4facfe;
      border-radius: 8px;
      padding: 12px 20px;
      font-weight: bold;
      font-size: 0.85em;
    }
    
    .arch-arrow {
      color: #22c55e;
      font-size: 1.5em;
    }
    
    /* Metric cards */
    .metric-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 15px;
      margin: 15px auto;
      max-width: 600px;
    }
    
    .metric-card {
      background: linear-gradient(135deg, rgba(79,172,254,0.1), rgba(136,87,255,0.1));
      border-radius: 10px;
      padding: 15px;
      text-align: center;
    }
    
    .metric-value {
      font-size: 2em;
      font-weight: bold;
      color: #4facfe;
    }
    
    .metric-label {
      font-size: 0.7em;
      color: #8b949e;
      margin-top: 5px;
    }
    
    /* Guarantee table */
    .guarantee-table {
      width: 90%;
      margin: 15px auto;
      border-collapse: collapse;
      font-size: 0.75em;
    }
    
    .guarantee-table th,
    .guarantee-table td {
      border: 1px solid #30363d;
      padding: 10px;
      text-align: left;
    }
    
    .guarantee-table th {
      background: rgba(79,172,254,0.2);
    }
    
    /* Animation Canvas */
    .animation-canvas {
      width: 100%;
      height: 250px;
      background: rgba(0,0,0,0.3);
      border-radius: 10px;
      position: relative;
      overflow: hidden;
      margin: 15px 0;
    }
    
    .control-panel {
      display: flex;
      gap: 10px;
      justify-content: center;
      margin-top: 10px;
    }
    
    .btn {
      background: linear-gradient(135deg, #4facfe, #00f2fe);
      border: none;
      padding: 8px 16px;
      border-radius: 6px;
      color: #fff;
      font-weight: bold;
      cursor: pointer;
      font-size: 0.75em;
      transition: transform 0.2s, box-shadow 0.2s;
    }
    
    .btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 15px rgba(79,172,254,0.4);
    }
    
    .btn.danger {
      background: linear-gradient(135deg, #ef4444, #f5576c);
    }
    
    .btn.success {
      background: linear-gradient(135deg, #22c55e, #4ade80);
    }
    
    .btn.secondary {
      background: linear-gradient(135deg, #6b7280, #9ca3af);
    }
    
    /* Result boxes */
    .result-box {
      padding: 10px 15px;
      border-radius: 6px;
      margin-top: 10px;
      font-size: 0.8em;
      display: none;
    }
    
    .result-box.success {
      background: rgba(34,197,94,0.2);
      border: 1px solid #22c55e;
      color: #22c55e;
    }
    
    .result-box.error {
      background: rgba(239,68,68,0.2);
      border: 1px solid #ef4444;
      color: #ef4444;
    }
    
    /* Log entry animation */
    .log-entry {
      background: rgba(79,172,254,0.1);
      border-left: 3px solid #4facfe;
      padding: 5px 10px;
      margin: 5px 0;
      font-family: 'Consolas', monospace;
      font-size: 0.7em;
      border-radius: 0 4px 4px 0;
      animation: slideIn 0.3s ease;
    }
    
    @keyframes slideIn {
      from { opacity: 0; transform: translateX(-20px); }
      to { opacity: 1; transform: translateX(0); }
    }
    
    .log-entry.corrupted {
      border-left-color: #ef4444;
      background: rgba(239,68,68,0.1);
      color: #ef4444;
    }
    
    /* Block visualization */
    .block-container {
      display: flex;
      gap: 5px;
      flex-wrap: wrap;
      justify-content: center;
      margin: 10px 0;
    }
    
    .data-block {
      width: 60px;
      height: 40px;
      border-radius: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.6em;
      font-weight: bold;
      transition: all 0.3s;
    }
    
    .data-block.searched {
      background: rgba(79,172,254,0.3);
      border: 2px solid #4facfe;
    }
    
    .data-block.found {
      background: rgba(34,197,94,0.5);
      border: 2px solid #22c55e;
      transform: scale(1.1);
    }
    
    .data-block.scanned {
      background: rgba(245,158,66,0.3);
      border: 2px solid #f59e42;
    }
  </style>
</head>
<body>
  <div class="reveal">
    <div class="slides">

      <!-- ============ TITLE SLIDE ============ -->
      <section data-background="linear-gradient(135deg, #0d1117 0%, #161b22 50%, #21262d 100%)">
        <h1>ğŸ” Episode 2.1</h1>
        <h2 style="color: #4facfe;">Sorted Logs</h2>
        <h3 style="color: #8b949e;">When Binary Search Meets Persistence</h3>
        
        <div style="margin-top: 30px;">
          <span class="leetcode-badge">LeetCode #704: Binary Search</span>
        </div>
        
        <div style="margin-top: 20px;">
          <span class="company-badge rocksdb">RocksDB</span>
          <span class="company-badge cassandra">Cassandra</span>
          <span class="company-badge bigtable">Bigtable</span>
        </div>
        
        <p style="margin-top: 30px; font-size: 0.7em; color: #8b949e;">
          Season 2: Binary Search â€” Building a Database Index
        </p>
        <aside class="notes">Welcome to Season 2! We're moving from linked lists to binary search - the foundation of every database index. Today we'll see how a simple algorithm becomes the beating heart of production storage systems.</aside>
      </section>

      <!-- ============ THE HOOK ============ -->
      <section>
        <h2>ğŸš¨ The 3 AM Page</h2>
        
        <div class="perfect-storm">
          <p style="font-size: 1.2em;">Database query that normally takes <strong style="color: #22c55e;">10ms</strong></p>
          <p style="font-size: 1.4em; margin-top: 10px;">Suddenly takes <strong style="color: #ef4444;">10 seconds</strong></p>
        </div>
        
        <div style="margin-top: 20px; font-size: 0.85em;">
          <p>âœ“ Indexes exist</p>
          <p>âœ“ Query plan looks right</p>
          <p>âœ“ No obvious errors</p>
        </div>
        
        <div class="dramatic-quote" style="margin-top: 25px;">
          "The answer lies in an algorithm you learned in CS 101..."
        </div>
        <aside class="notes">This is a real scenario. Database slowdowns often trace back to fundamental algorithmic issues. The index exists but can't be used efficiently. We'll learn why.</aside>
      </section>

      <!-- ============ THE CHALLENGE ============ -->
      <section>
        <h2>The Challenge</h2>
        
        <div style="display: flex; justify-content: space-between; align-items: center; margin: 30px 0;">
          <div style="text-align: left; flex: 1;">
            <h3 style="color: #4facfe;">Database Powers:</h3>
            <ul style="font-size: 0.75em; line-height: 1.4;">
              <li>Millions of writes per second</li>
              <li>Petabytes of data</li>
              <li>Sub-10ms query latency</li>
              <li>99.99% availability SLA</li>
            </ul>
          </div>
          <div style="font-size: 3em; color: #f59e42;">âš¡</div>
          <div style="text-align: left; flex: 1;">
            <h3 style="color: #ef4444;">The Question:</h3>
            <p style="font-size: 0.75em; line-height: 1.4;">
              How does a simple O(log n) search handle this scale?
            </p>
            <p style="font-size: 0.85em; color: #ef4444; font-weight: bold;">
              Answer: It doesn't. Not alone.
            </p>
          </div>
        </div>
        
        <div class="dramatic-quote">
          "This is the story of building, breaking, and hardening binary search for production."
        </div>
        <aside class="notes">Every major database - Cassandra, RocksDB, Bigtable - faces this challenge. The algorithm is simple, but the system around it is complex.</aside>
      </section>

      <!-- ============ THE JOURNEY ============ -->
      <section>
        <h2>Today's Journey</h2>
        
        <div class="architecture-flow">
          <div class="arch-box" style="background: rgba(255,161,22,0.2); border-color: #ffa116;">
            LeetCode #704<br><span style="font-size: 0.7em; opacity: 0.8;">Binary Search</span>
          </div>
          <div class="arch-arrow">â†’</div>
          <div class="arch-box">
            Write-Ahead Log<br><span style="font-size: 0.7em; opacity: 0.8;">Toy System</span>
          </div>
          <div class="arch-arrow">â†’</div>
          <div class="arch-box" style="background: rgba(239,68,68,0.2); border-color: #ef4444;">
            Scale Breaks<br><span style="font-size: 0.7em; opacity: 0.8;">3 Failures</span>
          </div>
          <div class="arch-arrow">â†’</div>
          <div class="arch-box" style="background: rgba(34,197,94,0.2); border-color: #22c55e;">
            SSTables<br><span style="font-size: 0.7em; opacity: 0.8;">Production</span>
          </div>
        </div>
        
        <div class="thesis-box" style="margin-top: 30px;">
          We'll <strong>build it</strong>, <strong style="color: #ef4444;">break it</strong>, and <strong style="color: #22c55e;">harden it</strong> into production
        </div>
        <aside class="notes">This is our roadmap. We start with the algorithm, build a toy system, watch it fail spectacularly, then engineer a production-grade solution.</aside>
      </section>

      <!-- ============ ACT I: THE ALGORITHM ============ -->
      <section>
        <section>
          <div class="act-title">
            <h1>ğŸ­ ACT I</h1>
            <h2>The Perfect Algorithm</h2>
          </div>
          <p class="act-intro">Where we meet binary search and discover its hidden requirement</p>
          <aside class="notes">Act 1 establishes the elegant simplicity of binary search. But we'll discover a requirement that changes everything.</aside>
        </section>
        
        <section>
          <h2><span class="leetcode-badge">LeetCode #704</span></h2>
          <h3>Binary Search</h3>
          
          <div class="feynman-diagram">
            <strong>Problem:</strong> Given a <em>sorted</em> array of integers, find target in O(log n) time
          </div>
          
          <pre><code class="language-python">def binary_search(arr, target):
    left, right = 0, len(arr) - 1
    
    while left <= right:
        mid = left + (right - left) // 2  # Avoid overflow
        
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    
    return -1</code></pre>
          
          <p style="margin-top: 15px; color: #22c55e; font-size: 0.75em;">
            âœ“ Clean code â€¢ âœ“ O(log n) time â€¢ âœ“ Simple logic
          </p>
          <aside class="notes">This is the interview question. Simple, elegant, and it works perfectly. Notice the requirement: SORTED array. That word 'sorted' becomes everything.</aside>
        </section>
        
        <section>
          <h2>ğŸ¯ Binary Search Demo</h2>
          <div class="animation-canvas" id="canvas-bsearch"></div>
          <div class="control-panel">
            <button class="btn" onclick="bsearchAnim.setTarget()">Set Random Target</button>
            <button class="btn success" onclick="bsearchAnim.runSearch()">Run Binary Search</button>
            <button class="btn secondary" onclick="bsearchAnim.reset()">Reset</button>
          </div>
          <pre style="margin-top: 10px;"><code id="bsearch-output" class="language-python" style="max-height: 100px;">
# Click "Run Binary Search" to see it in action...</code></pre>
          <aside class="notes">Watch how binary search eliminates half the search space with each comparison. This is the power of O(log n).</aside>
        </section>
        
        <section>
          <h3>Complexity Analysis</h3>
          <div class="stats-row">
            <div class="stat-card">
              <div class="stat-label">Time</div>
              <div class="stat-value">O(log n)</div>
            </div>
            <div class="stat-card">
              <div class="stat-label">Space</div>
              <div class="stat-value">O(1)</div>
            </div>
            <div class="stat-card">
              <div class="stat-label">Comparisons (1M items)</div>
              <div class="stat-value">~20</div>
            </div>
          </div>
          
          <div class="feynman-why" style="margin-top: 20px;">
            <strong>ğŸ’¡ Why O(log n)?</strong> Each comparison eliminates half the remaining elements.
            <br><br>
            For n = 1,000,000: logâ‚‚(1,000,000) â‰ˆ 20 comparisons
          </div>
          <aside class="notes">Log base 2 of a million is about 20. That's the magic - we can search a million items with just 20 comparisons.</aside>
        </section>
        
        <section>
          <h2>The Fundamental Requirement</h2>
          
          <div style="font-size: 3em; margin: 30px 0; color: #4facfe;">
            ğŸ“Š SORTED DATA
          </div>
          
          <div class="feynman-diagram">
            <strong>The Insight:</strong> Binary search only works on <em>sorted</em> data.<br><br>
            This "obvious" constraint becomes <strong>everything</strong> when we move to production systems.
          </div>
          
          <p style="margin-top: 20px; font-size: 0.85em;">
            The real concept isn't O(log n) searchâ€”<br>
            it's <strong style="color: #f59e42;">maintaining sorted order</strong> for efficient lookup.
          </p>
          
          <div class="dramatic-quote">
            "This is the DNA of database indexes."
          </div>
          <aside class="notes">Here's the key insight. Binary search is easy. Keeping data sorted while handling millions of writes per second - that's the hard part.</aside>
        </section>
        
        <section>
          <h2>What Makes This Hard?</h2>
          
          <div class="comparison-dramatic">
            <div class="comparison-side algorithm">
              <h3 style="color: #4facfe;">ğŸ“š In Memory</h3>
              <ul>
                <li>Data already sorted</li>
                <li>Random access: O(1)</li>
                <li>No persistence needed</li>
                <li>Single thread</li>
              </ul>
            </div>
            <div class="comparison-side broken">
              <h3 style="color: #ef4444;">ğŸ’½ On Disk</h3>
              <ul>
                <li>Data arrives unsorted</li>
                <li>Random access: 10ms seeks</li>
                <li>Must survive crashes</li>
                <li>Concurrent writers</li>
              </ul>
            </div>
          </div>
          
          <div class="scale-break" style="margin-top: 20px;">
            <strong>The Gap:</strong> LeetCode gives you sorted data. Production makes you earn it.
          </div>
          <aside class="notes">This is the gap between interview prep and production. In interviews, data is pre-sorted. In production, you're constantly fighting to maintain sorted order.</aside>
        </section>
      </section>

      <!-- ============ ACT II: TOY SYSTEM ============ -->
      <section>
        <section>
          <div class="act-title">
            <h1>ğŸ­ ACT II</h1>
            <h2>The Toy System</h2>
          </div>
          <p class="act-intro">Where we build a Write-Ahead Log and watch it break</p>
          <aside class="notes">Now we build something real. A Write-Ahead Log is the foundation of database durability. Every database has one.</aside>
        </section>
        
        <section>
          <h2>ğŸ—„ï¸ Write-Ahead Logging</h2>
          
          <div class="scale-break">
            <strong>The Problem:</strong> Every database needs <em>durability</em>.<br>
            If power fails, committed writes shouldn't disappear.
          </div>
          
          <div class="architecture-flow" style="margin-top: 25px;">
            <div class="arch-box">Write Request</div>
            <div class="arch-arrow">â†’</div>
            <div class="arch-box" style="background: rgba(255,107,0,0.2); border-color: #ff6b00;">WAL (Disk)</div>
            <div class="arch-arrow">â†’</div>
            <div class="arch-box">Acknowledge</div>
            <div class="arch-arrow">â†’</div>
            <div class="arch-box" style="opacity: 0.5;">Main DB (async)</div>
          </div>
          
          <p style="margin-top: 20px; font-size: 0.8em; color: #8b949e;">
            Before data goes to main DB, it gets written to a log on disk.<br>
            This ensures we can recover after any crash.
          </p>
          <aside class="notes">WAL is the key to durability. Write to the log first, acknowledge to the client, then lazily update the main database. If we crash, we replay the log.</aside>
        </section>
        
        <section>
          <h2>ToyWAL Design</h2>
          
          <div class="comparison-dramatic">
            <div class="comparison-side algorithm">
              <h3 style="color: #4facfe;">ğŸ“ Structure</h3>
              <ul>
                <li>Append-only log file</li>
                <li>Entry: <code>timestamp|key|value</code></li>
                <li>In-memory index â†’ file positions</li>
                <li>O(1) lookups via hash map</li>
              </ul>
            </div>
            <div class="comparison-side engineering">
              <h3 style="color: #22c55e;">âœ“ Guarantees</h3>
              <ul>
                <li>Durability (fsync)</li>
                <li>Fast writes (append)</li>
                <li>Fast reads (in-memory index)</li>
                <li>Simple implementation</li>
              </ul>
            </div>
          </div>
          <aside class="notes">This is our toy design. Append-only for fast writes. In-memory index for fast reads. What could go wrong?</aside>
        </section>
        
        <section>
          <h3>ToyWAL Implementation</h3>
          
          <pre><code class="language-python">class ToyWAL:
    def __init__(self, log_file="wal.log"):
        self.log_file = log_file
        self.index = {}  # key -> file_position
        
    def append(self, key, value):
        """Append a key-value pair to the log"""
        entry = f"{time.time()}|{key}|{value}\n"
        with open(self.log_file, 'a') as f:
            pos = f.tell()  # Get current position
            f.write(entry)
            f.flush()  # Force write to disk
        self.index[key] = pos  # Update in-memory index
        return True
        
    def get(self, key):
        """O(1) lookup using in-memory index"""
        if key not in self.index:
            return None
        pos = self.index[key]
        with open(self.log_file, 'r') as f:
            f.seek(pos)
            line = f.readline()
            _, _, value = line.strip().split('|')
        return value</code></pre>
        <aside class="notes">Clean, simple code. Append-only writes are fast. Index lookup is O(1). This passes the code review... but fails in production.</aside>
        </section>
        
        <section>
          <h2>ğŸ“ WAL Demo</h2>
          <div class="animation-canvas" id="canvas-wal" style="height: 200px;"></div>
          <div class="control-panel">
            <button class="btn" onclick="walAnim.appendEntry()">Append Entry</button>
            <button class="btn success" onclick="walAnim.lookupKey()">Lookup Key</button>
            <button class="btn danger" onclick="walAnim.simulateCrash()">ğŸ’¥ Crash!</button>
            <button class="btn secondary" onclick="walAnim.reset()">Reset</button>
          </div>
          <div id="wal-status" style="margin-top: 10px; font-size: 0.8em; color: #8b949e;"></div>
          <aside class="notes">Watch how the WAL works. Append is fast - just write to end of file. Lookup uses the in-memory index. But what happens when we crash?</aside>
        </section>
        
        <section>
          <h2>âš ï¸ The Critical Assumption</h2>
          
          <div class="failure-mode">
            <h3 style="margin-top: 0;">ğŸ’€ The index lives in MEMORY</h3>
            <p>What happens when we restart the process?</p>
          </div>
          
          <pre><code class="language-python">def rebuild_index(self):
    """Rebuild index by scanning entire log - this is the bottleneck!"""
    self.index = {}
    with open(self.log_file, 'r') as f:
        pos = 0
        for line in f:  # O(n) - reads EVERYTHING!
            timestamp, key, value = line.strip().split('|')
            self.index[key] = pos
            pos += len(line)</code></pre>
          
          <div class="perfect-storm" style="margin-top: 15px; padding: 15px;">
            With 1TB of data â†’ <strong>3+ hours downtime</strong> per restart
          </div>
          <aside class="notes">This is the fatal flaw. The in-memory index is fast, but it's lost on restart. Rebuilding means reading the ENTIRE log. At production scale, that's hours of downtime.</aside>
        </section>
      </section>

      <!-- ============ ACT III: FAILURE MODES ============ -->
      <section>
        <section>
          <div class="act-title">
            <h1>ğŸ­ ACT III</h1>
            <h2>The Breaking Point</h2>
          </div>
          <p class="act-intro">Where production scale destroys our beautiful toy</p>
          <aside class="notes">Time to break things. We'll run our toy at production scale and watch it fail in three spectacular ways.</aside>
        </section>
        
        <section data-background-gradient="linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%)">
          <h3>âš ï¸ Scale Breaks Ahead...</h3>
          <h2 style="color:#f59e42;">Our Toy System Faces Reality</h2>
          
          <div style="display:flex; gap:15px; justify-content:center; flex-wrap:wrap; margin-top:30px;">
            <div class="stat-card" style="background:rgba(245,87,108,0.15); border:1px solid #f5576c;">
              <div class="stat-value" style="color:#f5576c; font-size:1.4em;">â±ï¸</div>
              <div class="stat-label">Failure #1</div>
              <div style="font-size:0.6em; opacity:0.8;">Rebuild Time</div>
            </div>
            <div class="stat-card" style="background:rgba(245,158,66,0.15); border:1px solid #f59e42;">
              <div class="stat-value" style="color:#f59e42; font-size:1.4em;">ğŸ’¥</div>
              <div class="stat-label">Failure #2</div>
              <div style="font-size:0.6em; opacity:0.8;">Concurrent Writes</div>
            </div>
            <div class="stat-card" style="background:rgba(147,51,234,0.15); border:1px solid #9333ea;">
              <div class="stat-value" style="color:#9333ea; font-size:1.4em;">ğŸ“ˆ</div>
              <div class="stat-label">Failure #3</div>
              <div style="font-size:0.6em; opacity:0.8;">Unbounded Growth</div>
            </div>
          </div>
          <aside class="notes">Three failures await. Each one teaches a fundamental principle that production databases must handle.</aside>
        </section>
        
        <section>
          <h2><span style="background: #ef4444; padding: 5px 15px; border-radius: 5px;">Failure Mode #1</span></h2>
          <h3>The Rebuild Time Problem</h3>
          
          <pre><code class="language-python"># Process crashes, memory is wiped
# To restart: must call rebuild_index()

# With 1TB log at 100MB/s sequential read:
# 1TB / 100MB/s = 10,000 seconds = ~3 hours downtime

# Every restart = 3 hours offline
# In production: UNACCEPTABLE</code></pre>
          
          <div class="metric-grid" style="margin-top: 15px;">
            <div class="metric-card">
              <div class="metric-value" style="color: #ef4444;">3 hours</div>
              <div class="metric-label">Downtime per restart</div>
            </div>
            <div class="metric-card">
              <div class="metric-value" style="color: #ef4444;">$$$</div>
              <div class="metric-label">SLA violations</div>
            </div>
          </div>
          
          <div class="engineering-solution" style="margin-top: 20px;">
            <strong>ğŸ’¡ Solution:</strong> Make the log itself searchable without full scan<br>
            <span style="color: #22c55e;">â†’ Sorted on-disk structure</span>
          </div>
          <aside class="notes">Three hours of downtime for every restart. That's a career-ending outage. The solution: don't rely on in-memory indexes.</aside>
        </section>
        
        <section>
          <h2>ğŸï¸ Rebuild Time Race</h2>
          <div class="animation-canvas" id="canvas-rebuild"></div>
          <div class="control-panel">
            <button class="btn danger" onclick="rebuildAnim.startRebuild()">Start Rebuild (O(n))</button>
            <button class="btn success" onclick="rebuildAnim.startSparse()">Start Sparse Index (O(log n))</button>
            <button class="btn secondary" onclick="rebuildAnim.reset()">Reset</button>
          </div>
          <div id="rebuild-result" class="result-box"></div>
          <aside class="notes">Watch the difference. Full scan takes forever. With a sparse on-disk index, we only read block headers - orders of magnitude faster.</aside>
        </section>
        
        <section>
          <h2><span style="background: #ef4444; padding: 5px 15px; border-radius: 5px;">Failure Mode #2</span></h2>
          <h3>Concurrent Writes Corrupt Data</h3>
          
          <pre><code class="language-python"># Two threads writing simultaneously
threads = [
    Thread(target=lambda: wal.append(f"key:{i}", f"value:{i}"))
    for i in range(1000)
]
[t.start() for t in threads]

# Result in log file:
# "1234|key:1|val1234|key:2|val"  â† MANGLED!
# File append() is NOT atomic across threads</code></pre>
          
          <div class="failure-mode" style="animation: none; margin-top: 15px;">
            <strong>ğŸ’€ Data Corruption:</strong> Entries interleaved, no newlines, unreadable garbage
          </div>
          
          <div class="engineering-solution" style="margin-top: 15px;">
            <strong>ğŸ’¡ Solution:</strong> Batch writes in memory, flush atomically
          </div>
          <aside class="notes">Append-only doesn't mean thread-safe! Multiple threads can interleave their writes, producing corrupted output.</aside>
        </section>
        
        <section>
          <h2>ğŸ’¥ Corruption Demo</h2>
          <div class="animation-canvas" id="canvas-corrupt" style="height: 180px;"></div>
          <div class="control-panel">
            <button class="btn" onclick="corruptAnim.singleWrite()">Single Thread Write</button>
            <button class="btn danger" onclick="corruptAnim.concurrentWrite()">Concurrent Write ğŸ’¥</button>
            <button class="btn secondary" onclick="corruptAnim.reset()">Reset</button>
          </div>
          <pre style="margin-top: 10px;"><code id="corrupt-output" class="language-text" style="max-height: 80px;">Log file contents will appear here...</code></pre>
          <aside class="notes">Single thread writes cleanly. But watch what happens with concurrent writes - the entries get mangled together.</aside>
        </section>
        
        <section>
          <h2><span style="background: #ef4444; padding: 5px 15px; border-radius: 5px;">Failure Mode #3</span></h2>
          <h3>Unbounded Growth Problem</h3>
          
          <pre><code class="language-python"># Updates create duplicate entries
wal.append("user:100", "Alice")
wal.append("user:100", "Alice-Updated")  # Old entry still on disk!
wal.append("user:100", "Alice-Updated-Again")  # 3 copies now!

wal.append("user:101", "DELETE")  # Tombstone marker - data gone but space used

# After 1 year of operation:
# - 10TB of log data on disk
# - Only 1TB is current data
# - 90% of disk space wasted!</code></pre>
          
          <div class="engineering-solution" style="margin-top: 15px;">
            <strong>ğŸ’¡ Solution:</strong> Compaction â€” merge old entries, remove tombstones
          </div>
          <aside class="notes">Every update adds a new entry. Deletes add tombstones. Over time, 90% of your disk is garbage. We need compaction.</aside>
        </section>
        
        <section>
          <h2>ğŸ“ˆ Growth Demo</h2>
          <div class="animation-canvas" id="canvas-growth"></div>
          <div class="control-panel">
            <button class="btn" onclick="growthAnim.addUpdates()">Add 100 Updates</button>
            <button class="btn success" onclick="growthAnim.runCompaction()">Run Compaction</button>
            <button class="btn secondary" onclick="growthAnim.reset()">Reset</button>
          </div>
          <div style="margin-top: 10px; display: flex; gap: 20px; justify-content: center;">
            <div>Total: <span id="growth-total" style="color: #4facfe; font-weight: bold;">0</span> entries</div>
            <div>Active: <span id="growth-active" style="color: #22c55e; font-weight: bold;">0</span> entries</div>
            <div>Waste: <span id="growth-waste" style="color: #ef4444; font-weight: bold;">0%</span></div>
          </div>
          <aside class="notes">Watch the waste grow. Updates pile up. Compaction reclaims that space by merging and removing old versions.</aside>
        </section>
        
        <section>
          <h2>Summary: The Three Failures</h2>
          
          <table class="guarantee-table">
            <tr>
              <th>Failure</th>
              <th>Cause</th>
              <th>Solution</th>
            </tr>
            <tr>
              <td style="color: #ef4444;">Rebuild Time</td>
              <td>In-memory index lost on crash</td>
              <td style="color: #22c55e;">Sorted on-disk structure</td>
            </tr>
            <tr>
              <td style="color: #ef4444;">Corruption</td>
              <td>Concurrent writes interleave</td>
              <td style="color: #22c55e;">Batch + atomic flush</td>
            </tr>
            <tr>
              <td style="color: #ef4444;">Unbounded Growth</td>
              <td>Old entries never removed</td>
              <td style="color: #22c55e;">Compaction</td>
            </tr>
          </table>
          
          <div class="thesis-box" style="margin-top: 20px;">
            All three solutions lead us to the same architecture: <strong>SSTables</strong>
          </div>
          <aside class="notes">Notice how all three failures point to the same solution. We need sorted, immutable, compactable segments. That's an SSTable.</aside>
        </section>
      </section>

      <!-- ============ ACT IV: PRODUCTION HARDENING ============ -->
      <section>
        <section>
          <div class="act-title">
            <h1>ğŸ­ ACT IV</h1>
            <h2>The Resurrection</h2>
          </div>
          <p class="act-intro">Where SSTables save the day</p>
          <aside class="notes">Now we build the real thing. SSTables - Sorted String Tables - are the foundation of modern databases. Let's see how they solve all three failures.</aside>
        </section>
        
        <section>
          <h2>ğŸ—ï¸ Enter: SSTables</h2>
          <h3 style="color: #8b949e;">Sorted String Tables</h3>
          
          <div style="margin: 25px 0;">
            <span class="company-badge rocksdb">RocksDB</span>
            <span class="company-badge cassandra">Cassandra</span>
            <span class="company-badge bigtable">Bigtable</span>
          </div>
          
          <div class="thesis-box">
            The foundation of modern databases for 20+ years
          </div>
          
          <div class="feynman-diagram" style="margin-top: 20px;">
            <strong>Key Insight:</strong> Don't binary search millions of entries.<br><br>
            Instead: Binary search <em>hundreds of blocks</em>, then scan one 4KB block.
          </div>
          <aside class="notes">SSTables were invented at Google for Bigtable. Now they power RocksDB, Cassandra, LevelDB, and countless other systems.</aside>
        </section>
        
        <section>
          <h2>Two-Level Search</h2>
          
          <pre style="font-size: 0.55em; text-align: center; background: rgba(255,255,255,0.05); padding: 15px; border-radius: 8px;"><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        SPARSE INDEX (in memory)                      â”‚
â”‚  "aaa" â†’ 0      "dog" â†’ 4096     "fox" â†’ 8192     "zoo" â†’ 12288    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â†“                â†“                â†“                â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Block 0    â”‚   Block 1    â”‚   Block 2    â”‚   Block 3    â”‚
â”‚   4KB        â”‚   4KB        â”‚   4KB        â”‚   4KB        â”‚
â”‚  aaa...dog   â”‚  dog...fox   â”‚  fox...zoo   â”‚  zoo...zzz   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Step 1: Binary search sparse index â†’ find block    O(log B)
Step 2: Sequential scan 4KB block â†’ find key       O(K)</code></pre>
          
          <div class="metric-grid" style="margin-top: 20px;">
            <div class="metric-card">
              <div class="metric-value">250M</div>
              <div class="metric-label">Blocks (1TB @ 4KB)</div>
            </div>
            <div class="metric-card">
              <div class="metric-value">~28</div>
              <div class="metric-label">Index Lookups</div>
            </div>
          </div>
          <aside class="notes">The magic of two-level search. Binary search the sparse index (tiny), then linear scan one block (fast because sequential). Massively faster than searching all entries.</aside>
        </section>
        
        <section>
          <h2>ğŸ” SSTable Search Demo</h2>
          <div class="animation-canvas" id="canvas-sstable"></div>
          <div class="control-panel">
            <button class="btn" onclick="sstableAnim.setTarget()">Set Random Target</button>
            <button class="btn success" onclick="sstableAnim.runSearch()">Run Two-Level Search</button>
            <button class="btn secondary" onclick="sstableAnim.reset()">Reset</button>
          </div>
          <div id="sstable-result" class="result-box"></div>
          <aside class="notes">Watch the two-level search in action. First we binary search the sparse index, then we scan just one block.</aside>
        </section>
        
        <section>
          <h3>SSTable Segment Implementation</h3>
          
          <pre><code class="language-python">class SSTableSegment:
    def __init__(self, filename):
        self.filename = filename
        self.sparse_index = {}  # first_key â†’ file_offset
        self.block_size = 4096  # 4KB blocks
        
    def get(self, target_key):
        # Step 1: Binary search sparse index
        block_keys = sorted(self.sparse_index.keys())
        block_idx = bisect.bisect_right(block_keys, target_key) - 1
        if block_idx < 0:
            return None
            
        block_offset = self.sparse_index[block_keys[block_idx]]
        
        # Step 2: Sequential scan one 4KB block
        with open(self.filename, 'rb') as f:
            f.seek(block_offset)
            block_data = f.read(self.block_size)
            for line in block_data.decode().split('\n'):
                key, value = line.split(':', 1)
                if key == target_key:
                    return value
        return None</code></pre>
        <aside class="notes">Here's the actual implementation. Binary search the index, seek to the block, scan sequentially. Simple but powerful.</aside>
        </section>
        
        <section>
          <h2>Production Architecture</h2>
          
          <div class="architecture-flow">
            <div class="arch-box" style="background: rgba(255,161,22,0.2); border-color: #ffa116;">
              Write
            </div>
            <div class="arch-arrow">â†’</div>
            <div class="arch-box" style="background: rgba(136,87,255,0.2); border-color: #8957ff;">
              Memtable<br><span style="font-size: 0.7em;">(In-Memory)</span>
            </div>
            <div class="arch-arrow">â†’</div>
            <div class="arch-box" style="background: rgba(34,197,94,0.2); border-color: #22c55e;">
              SSTable<br><span style="font-size: 0.7em;">(On-Disk)</span>
            </div>
          </div>
          
          <div class="comparison-dramatic" style="margin-top: 25px;">
            <div class="comparison-side algorithm">
              <h4 style="color: #8957ff;">Memtable</h4>
              <ul>
                <li>Fast writes (memory)</li>
                <li>Sorted structure (red-black tree)</li>
                <li>Size limited (64MB)</li>
                <li>Volatile (WAL for recovery)</li>
              </ul>
            </div>
            <div class="comparison-side engineering">
              <h4 style="color: #22c55e;">SSTable</h4>
              <ul>
                <li>Durable (disk)</li>
                <li>Immutable (never modified)</li>
                <li>Sorted (binary searchable)</li>
                <li>Compacted periodically</li>
              </ul>
            </div>
          </div>
          <aside class="notes">The full architecture: writes go to memtable first, then flush to immutable SSTables. Memtable is fast, SSTable is durable.</aside>
        </section>
        
        <section>
          <h2>ğŸ“– Read Path</h2>
          
          <pre><code class="language-python">def get(self, key):
    # 1. Check memtable first (hottest, most recent)
    if key in self.memtable:
        return self.memtable[key]
    
    # 2. Check SSTables newest to oldest
    for segment in reversed(self.segments):
        value = segment.get(key)
        if value is not None:
            return value
    
    return None  # Key not found</code></pre>
          
          <div class="feynman-why" style="margin-top: 20px;">
            <strong>ğŸ’¡ Key Insight:</strong> Check hot data first (memtable), then cold data (SSTables).<br>
            Newest segment wins â€” handles updates correctly.
          </div>
          <aside class="notes">The read path exploits temporal locality. Recent writes are in memtable (fast). Older data is in SSTables. Newest value wins for updates.</aside>
        </section>
        
        <section>
          <h2>âœï¸ Write Path</h2>
          
          <pre><code class="language-python">def put(self, key, value):
    # Backpressure: block if memtable full
    if self.memtable_size > self.max_memtable_size:
        self._flush_memtable_to_disk()
    
    # Write to in-memory buffer (fast!)
    self.memtable[key] = value
    self.memtable_size += len(key) + len(value)
    
    # Also write to WAL for crash recovery
    self.wal.append(key, value)</code></pre>
          
          <div class="engineering-solution" style="margin-top: 15px;">
            <strong>O(1) amortized writes</strong> â€” memory is fast!<br>
            WAL ensures durability even if memtable is lost.
          </div>
          <aside class="notes">Writes are fast because they hit memory first. WAL ensures durability. When memtable fills up, we flush to a new SSTable.</aside>
        </section>
        
        <section>
          <h2>ï¿½ The Immutability Principle</h2>
          
          <div class="thesis-box">
            SSTables are <strong>NEVER modified</strong> after creation
          </div>
          
          <div class="comparison-dramatic" style="margin-top: 25px;">
            <div class="comparison-side broken">
              <h4 style="color: #ef4444;">âŒ What Doesn't Happen</h4>
              <ul>
                <li>No in-place updates</li>
                <li>No index modifications</li>
                <li>No block rewrites</li>
                <li>No file appends</li>
              </ul>
            </div>
            <div class="comparison-side engineering">
              <h4 style="color: #22c55e;">âœ“ What Actually Happens</h4>
              <ul>
                <li>New data â†’ Memtable</li>
                <li>Memtable full â†’ NEW SSTable</li>
                <li>Compaction â†’ NEW SSTable</li>
                <li>Old files deleted atomically</li>
              </ul>
            </div>
          </div>
          
          <div class="feynman-why" style="margin-top: 20px;">
            <strong>ğŸ’¡ Why Immutability?</strong> No locks needed for reads. Crash recovery is trivial. Files are always in consistent state.
          </div>
          <aside class="notes">This is the most important principle. SSTables never change. Updates create new files. This simplifies everything - no locks for readers, no partial writes, no corruption.</aside>
        </section>
        
        <section>
          <h2>ğŸ—ï¸ How Indexes Are Built</h2>
          <p style="font-size: 0.8em; color: #8b949e;">Indexes are created <strong>once</strong> during Memtable flush â€” never updated!</p>
          
          <div class="animation-canvas" id="canvas-indexbuild" style="height: 280px;"></div>
          <div class="control-panel">
            <button class="btn" onclick="indexBuildAnim.startFlush()">â–¶ï¸ Flush Memtable â†’ SSTable</button>
            <button class="btn secondary" onclick="indexBuildAnim.reset()">Reset</button>
          </div>
          <div id="indexbuild-status" style="margin-top: 10px; font-size: 0.8em; color: #8b949e;"></div>
          <aside class="notes">Watch the index being built as the memtable flushes. Each block's first key goes into the sparse index. The index is complete when the file is written. No incremental updates!</aside>
        </section>
        
        <section>
          <h2>ğŸ—‘ï¸ Deletes = Tombstones</h2>
          
          <div class="scale-break">
            <strong>Problem:</strong> How do you "delete" from an immutable file?<br>
            <strong>Answer:</strong> You don't. You write a <em>tombstone marker</em>.
          </div>
          
          <div class="animation-canvas" id="canvas-tombstone" style="height: 220px;"></div>
          <div class="control-panel">
            <button class="btn" onclick="tombstoneAnim.writeData()">1ï¸âƒ£ Write Data</button>
            <button class="btn danger" onclick="tombstoneAnim.deleteData()">2ï¸âƒ£ Delete (Tombstone)</button>
            <button class="btn" onclick="tombstoneAnim.readData()">3ï¸âƒ£ Read Key</button>
            <button class="btn success" onclick="tombstoneAnim.runCompaction()">4ï¸âƒ£ Compaction</button>
            <button class="btn secondary" onclick="tombstoneAnim.reset()">Reset</button>
          </div>
          <div id="tombstone-status" style="margin-top: 10px; font-size: 0.8em; color: #8b949e;"></div>
          <aside class="notes">Deletes don't remove data - they add a tombstone marker in a NEW SSTable. Original data is still on disk! Only compaction actually reclaims space.</aside>
        </section>
        
        <section>
          <h2>ğŸ“Š Operations Summary</h2>
          
          <table class="guarantee-table">
            <tr>
              <th>Operation</th>
              <th>What Happens</th>
              <th>Index Impact</th>
            </tr>
            <tr>
              <td style="color: #22c55e;"><strong>Add</strong></td>
              <td>â†’ Memtable â†’ NEW SSTable on flush</td>
              <td>New index built during flush</td>
            </tr>
            <tr>
              <td style="color: #4facfe;"><strong>Update</strong></td>
              <td>Same as Add (newer wins on read)</td>
              <td>New entry in new SSTable's index</td>
            </tr>
            <tr>
              <td style="color: #ef4444;"><strong>Delete</strong></td>
              <td>Tombstone â†’ Memtable â†’ SSTable</td>
              <td>Tombstone indexed like any entry</td>
            </tr>
            <tr>
              <td style="color: #8957ff;"><strong>Compaction</strong></td>
              <td>Merge SSTables, remove tombstones</td>
              <td>Entirely NEW index for merged file</td>
            </tr>
          </table>
          
          <div class="thesis-box" style="margin-top: 20px;">
            Indexes are <strong>created fresh</strong> â€” never updated in place!
          </div>
          <aside class="notes">This table summarizes everything. Every operation results in new files with new indexes. Nothing is ever modified in place. This is the key to SSTable's simplicity and reliability.</aside>
        </section>
        
        <section>
          <h2>ï¿½ğŸ”„ Compaction</h2>
          <p style="font-size: 0.8em; color: #8b949e;">Merge segments, remove tombstones, reclaim space</p>
          
          <pre><code class="language-python">def _compact_segments(self):
    # Merge multiple segments into one
    merged_entries = []
    for segment in self.segments[-3:]:
        merged_entries.extend(segment.read_all_entries())
    
    # Remove tombstones, keep latest version
    latest = {}
    for key, value in sorted(merged_entries):
        if value != "DELETE":
            latest[key] = value
    
    # Write new compacted segment
    new_segment = SSTableSegment(f"compact_{time.time()}.sst")
    new_segment.write_segment(sorted(latest.items()))
    
    # Replace old segments with compacted one
    self.segments = self.segments[:-3] + [new_segment]</code></pre>
        <aside class="notes">Compaction merges multiple SSTables into one, removing deleted entries and old versions. This reclaims disk space and speeds up reads.</aside>
        </section>
        
        <section>
          <h2>ğŸ”„ Compaction Demo</h2>
          <div class="animation-canvas" id="canvas-compact"></div>
          <div class="control-panel">
            <button class="btn" onclick="compactAnim.addSegments()">Add 3 Segments</button>
            <button class="btn success" onclick="compactAnim.runCompaction()">Run Compaction</button>
            <button class="btn secondary" onclick="compactAnim.reset()">Reset</button>
          </div>
          <div style="margin-top: 10px; font-size: 0.8em;">
            Segments: <span id="compact-count" style="color: #4facfe; font-weight: bold;">0</span> |
            Total Entries: <span id="compact-entries" style="color: #22c55e; font-weight: bold;">0</span>
          </div>
          <aside class="notes">Watch compaction in action. Multiple segments merge into one, eliminating duplicates and tombstones.</aside>
        </section>
        
        <section>
          <h2>ğŸ”’ Concurrent Access</h2>
          
          <pre><code class="language-python">class ConcurrentSSTable:
    def __init__(self):
        self.rwlock = threading.Lock()
        self.readers = 0
        
    def get_with_lock(self, key):
        with self.rwlock:
            while self.writer:
                self.reader_cond.wait()
            self.readers += 1
        try:
            return self._internal_get(key)
        finally:
            with self.rwlock:
                self.readers -= 1
                if self.readers == 0:
                    self.writer_cond.notify()</code></pre>
          
          <div class="feynman-why" style="margin-top: 15px;">
            <strong>ğŸ’¡ Readers-Writer Lock:</strong> Multiple readers OR one writer.<br>
            SSTables are immutable â€” readers never block each other!
          </div>
          <aside class="notes">Concurrency is handled with readers-writer locks. But here's the magic: SSTables are immutable, so readers never conflict with each other.</aside>
        </section>
        
        <section>
          <h2>ğŸ“Š Production Monitoring</h2>
          
          <pre><code class="language-python">self.metrics = {
    'write_ops_total': 0,
    'read_ops_total': 0,
    'memtable_flushes': 0,
    'disk_bytes_read': 0,
    'p99_read_latency_ms': 0,
    'segment_count': 0,
    'compaction_running': False
}</code></pre>
          
          <div class="metric-grid" style="margin-top: 20px;">
            <div class="metric-card">
              <div class="metric-value">&lt;10ms</div>
              <div class="metric-label">P99 Read Latency</div>
            </div>
            <div class="metric-card">
              <div class="metric-value">&lt;50ms</div>
              <div class="metric-label">P99 Write Latency</div>
            </div>
          </div>
          <aside class="notes">Every production system needs observability. Track latencies, throughput, compaction status. Without metrics, you're flying blind.</aside>
        </section>
        
        <section>
          <h2>ğŸ“œ Production Guarantees</h2>
          
          <table class="guarantee-table">
            <tr>
              <th>Guarantee</th>
              <th>How We Achieve It</th>
            </tr>
            <tr>
              <td><strong style="color: #22c55e;">Durability</strong></td>
              <td>WAL + fsync before acknowledge</td>
            </tr>
            <tr>
              <td><strong style="color: #4facfe;">Consistency</strong></td>
              <td>Readers see all committed writes</td>
            </tr>
            <tr>
              <td><strong style="color: #f59e42;">Performance</strong></td>
              <td>O(log n) reads, O(1) amortized writes</td>
            </tr>
            <tr>
              <td><strong style="color: #8957ff;">Recovery</strong></td>
              <td>&lt;30 seconds for 1TB (sparse index)</td>
            </tr>
          </table>
          <aside class="notes">These are the guarantees we can now make. Durability via WAL. Fast recovery via sparse indexes. Performance via two-level search.</aside>
        </section>
        
        <section>
          <h2>âœ… All Failures Handled</h2>
          
          <div class="comparison-dramatic">
            <div class="comparison-side engineering">
              <h4 style="color: #22c55e;">Process Crash</h4>
              <p>Recover from WAL + sparse indexes</p>
              <p style="font-size: 0.8em; opacity: 0.8;">Recovery: &lt;30 seconds</p>
            </div>
            <div class="comparison-side engineering">
              <h4 style="color: #22c55e;">Concurrent Writes</h4>
              <p>Memtable batching + atomic flush</p>
              <p style="font-size: 0.8em; opacity: 0.8;">No corruption possible</p>
            </div>
          </div>
          
          <div class="comparison-dramatic" style="margin-top: 15px;">
            <div class="comparison-side engineering">
              <h4 style="color: #22c55e;">Unbounded Growth</h4>
              <p>Background compaction</p>
              <p style="font-size: 0.8em; opacity: 0.8;">Automatic space reclaim</p>
            </div>
            <div class="comparison-side engineering">
              <h4 style="color: #22c55e;">Disk Corruption</h4>
              <p>Checksums on every block</p>
              <p style="font-size: 0.8em; opacity: 0.8;">Detect and skip bad data</p>
            </div>
          </div>
          <aside class="notes">Every failure mode from Act III is now handled. That's what production hardening looks like.</aside>
        </section>
      </section>

      <!-- ============ ACT V: NEXT PROBLEM ============ -->
      <section>
        <section>
          <div class="act-title">
            <h1>ğŸ­ ACT V</h1>
            <h2>The Next Challenge</h2>
          </div>
          <p class="act-intro">Where success creates new problems</p>
          <aside class="notes">We solved the storage problem. But success creates new challenges. Product has a new requirement...</aside>
        </section>
        
        <section>
          <h2>ğŸ¯ System Deployed!</h2>
          
          <div class="metric-grid">
            <div class="metric-card">
              <div class="metric-value">1M+</div>
              <div class="metric-label">Writes/Second</div>
            </div>
            <div class="metric-card">
              <div class="metric-value">5ms</div>
              <div class="metric-label">P99 Latency</div>
            </div>
          </div>
          
          <p style="margin-top: 20px; color: #22c55e; font-size: 1.2em;">ğŸ‰ The team is celebrating!</p>
          
          <div class="scale-break" style="margin-top: 25px;">
            <strong>Then Product comes with a new requirement...</strong>
          </div>
          <aside class="notes">Victory! Our system is deployed and performing great. But then the product manager walks over...</aside>
        </section>
        
        <section>
          <h2>ğŸ“‹ The New Requirement</h2>
          
          <div class="thesis-box" style="font-size: 1em;">
            "Show me all posts by <strong style="color: #4facfe;">user:12345</strong><br>
            from the <strong style="color: #22c55e;">last 7 days</strong>"
          </div>
          
          <pre><code class="language-python"># Our current API:
def get(key):  # Returns ONE value for ONE key
    ...

# No way to say:
# "Give me all keys matching a pattern"
# "Give me all keys in a time range"
# "Give me the next 20 keys after this cursor"</code></pre>
          
          <div class="dramatic-quote" style="margin-top: 15px;">
            We have point lookups. We need <strong>range queries</strong>.
          </div>
          <aside class="notes">Our API returns one value for one key. But real applications need ranges - all posts by a user, all events in a time window.</aside>
        </section>
        
        <section>
          <h2>Three Options</h2>
          
          <div class="failure-mode" style="animation: none;">
            <h4 style="margin: 0;">Option 1: Giant Blob</h4>
            <p>Store all posts in one value</p>
            <p style="font-size: 0.8em; opacity: 0.8;">Problem: Rewrite 1MB for each new post ğŸ˜±</p>
          </div>
          
          <div class="failure-mode" style="animation: none;">
            <h4 style="margin: 0;">Option 2: Million get() calls</h4>
            <p>1000 posts Ã— 10ms = 10 seconds latency</p>
            <p style="font-size: 0.8em; opacity: 0.8;">Problem: Users rage-quit ğŸ˜±</p>
          </div>
          
          <div class="engineering-solution">
            <h4 style="margin: 0;">Option 3: Range Queries âœ…</h4>
            <p>One seek to start, sequential scan â†’ Fast!</p>
            <p style="font-size: 0.8em;">This is what we need to build next.</p>
          </div>
          <aside class="notes">Options 1 and 2 don't scale. Option 3 is the right answer - but it requires new algorithms.</aside>
        </section>
        
        <section>
          <h2>ğŸ”® Next Episode Preview</h2>
          
          <h3 style="color: #4facfe;">Episode 2.2: Range Queries & Infinite Scroll</h3>
          
          <div style="margin: 20px 0;">
            <span class="leetcode-badge">LeetCode #34: Find First and Last Position</span>
          </div>
          
          <div class="feynman-diagram">
            <strong>lower_bound</strong> and <strong>upper_bound</strong><br>
            The fundamental operations for efficient range scans
          </div>
          
          <div class="dramatic-quote" style="margin-top: 20px;">
            We'll build <strong>infinite scroll pagination</strong> for social media feeds.<br>
            <span style="font-size: 0.8em; color: #8b949e;">At Twitter scale. Without duplicates or skips.</span>
          </div>
          <aside class="notes">Next episode: we add range queries. LeetCode #34 teaches us lower_bound and upper_bound - the foundation of pagination and infinite scroll.</aside>
        </section>
      </section>

      <!-- ============ KEY TAKEAWAYS ============ -->
      <section>
        <h2>ğŸ“š Key Takeaways</h2>
        
        <ol style="font-size: 0.8em; text-align: left; max-width: 90%; margin: 0 auto;">
          <li style="margin: 12px 0;">
            <strong style="color: #4facfe;">Binary Search â†’ Sorted Storage</strong><br>
            <span style="opacity: 0.8;">Algorithm's requirement becomes system's requirement</span>
          </li>
          <li style="margin: 12px 0;">
            <strong style="color: #ef4444;">Toy to Production Journey</strong><br>
            <span style="opacity: 0.8;">Simple log â†’ 3 failures â†’ hardened SSTable</span>
          </li>
          <li style="margin: 12px 0;">
            <strong style="color: #22c55e;">Production Patterns</strong><br>
            <span style="opacity: 0.8;">SSTables, Compaction, RW Locks, Checksums</span>
          </li>
          <li style="margin: 12px 0;">
            <strong style="color: #8957ff;">When to Use</strong><br>
            <span style="opacity: 0.8;">Write-heavy, read-recent workloads (LSM-tree pattern)</span>
          </li>
        </ol>
        <aside class="notes">Four key lessons. Binary search requires sorted data. Production systems must handle failures. SSTables are the proven pattern. Know when to use this architecture.</aside>
      </section>

      <!-- ============ THE BIG INSIGHT ============ -->
      <section>
        <h2>ğŸ’¡ The Big Insight</h2>
        
        <div class="feynman-diagram" style="font-size: 0.95em;">
          Every database index is fundamentally a <strong style="color: #4facfe;">sorted data structure</strong> 
          that enables <strong style="color: #22c55e;">binary search</strong>.
          <br><br>
          The innovation isn't the search algorithmâ€”it's <strong style="color: #f59e42;">maintaining that sorted order</strong> 
          efficiently on persistent storage while handling every possible failure mode.
        </div>
        
        <div class="dramatic-quote" style="margin-top: 25px;">
          "LeetCode teaches the algorithm. Production teaches the system."
        </div>
        <aside class="notes">This is what separates algorithm knowledge from systems engineering. The algorithm is easy. The system around it is hard.</aside>
      </section>

      <!-- ============ ENGINEERING LAYERS ============ -->
      <section>
        <h2>ğŸ—ï¸ Engineering Layers</h2>
        <div class="animation-canvas" id="canvas-layers"></div>
        <div class="control-panel">
          <button class="btn success" onclick="layersAnim.startAnimation()">Watch Evolution</button>
          <button class="btn secondary" onclick="layersAnim.reset()">Reset</button>
        </div>
        <aside class="notes">Watch how a simple algorithm grows into a production system. Each layer adds capability - and complexity.</aside>
      </section>

      <!-- ============ END SLIDE ============ -->
      <section data-background="linear-gradient(135deg, #0d1117 0%, #161b22 50%, #21262d 100%)">
        <h1>See You in Episode 2.2!</h1>
        <h2 style="color: #4facfe;">"Bound Search â€” The Infinite Scroll Algorithm"</h2>
        
        <div style="margin-top: 40px;">
          <span class="company-badge rocksdb">RocksDB</span>
          <span class="company-badge cassandra">Cassandra</span>
          <span class="company-badge bigtable">Bigtable</span>
        </div>
        
        <p style="margin-top: 30px; font-size: 0.7em; color: #8b949e;">
          Season 2: Binary Search â€” Building a Database Index
        </p>
        <aside class="notes">Thanks for watching! Next episode: range queries and infinite scroll. See you there!</aside>
      </section>

    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/reveal.js/dist/reveal.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/reveal.js/plugin/highlight/highlight.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/reveal.js/plugin/notes/notes.js"></script>
  <script>
    // ========== ANIMATION 1: Binary Search Demo ==========
    class BinarySearchAnimation {
      constructor(canvasId) {
        this.canvas = document.getElementById(canvasId);
        this.arr = [2, 5, 8, 12, 16, 23, 38, 45, 56, 72, 91, 94, 97, 99, 103];
        this.target = null;
        this.isSearching = false;
      }
      
      setTarget() {
        this.reset();
        this.target = this.arr[Math.floor(Math.random() * this.arr.length)];
        this.render();
        document.getElementById('bsearch-output').textContent = `# Target: ${this.target}\n# Click "Run Binary Search" to find it...`;
      }
      
      async runSearch() {
        if (!this.target || this.isSearching) return;
        this.isSearching = true;
        let left = 0, right = this.arr.length - 1;
        let steps = [];
        
        while (left <= right) {
          const mid = Math.floor((left + right) / 2);
          steps.push({ left, right, mid, comparison: this.arr[mid] < this.target ? 'less' : this.arr[mid] > this.target ? 'greater' : 'equal' });
          
          if (this.arr[mid] === this.target) break;
          else if (this.arr[mid] < this.target) left = mid + 1;
          else right = mid - 1;
        }
        
        for (let i = 0; i < steps.length; i++) {
          await this.animateStep(steps[i], i + 1);
          await new Promise(r => setTimeout(r, 800));
        }
        this.isSearching = false;
      }
      
      async animateStep(step, stepNum) {
        const output = document.getElementById('bsearch-output');
        output.textContent = `# Step ${stepNum}: left=${step.left}, right=${step.right}, mid=${step.mid}\n# arr[${step.mid}] = ${this.arr[step.mid]} ${step.comparison === 'less' ? '< ' + this.target + ' â†’ search right' : step.comparison === 'greater' ? '> ' + this.target + ' â†’ search left' : '== ' + this.target + ' â†’ FOUND!'}`;
        this.renderStep(step);
      }
      
      renderStep(step) {
        let html = '<div style="display:flex;gap:5px;justify-content:center;align-items:center;height:100%;flex-wrap:wrap;padding:20px;">';
        for (let i = 0; i < this.arr.length; i++) {
          let bg = 'rgba(255,255,255,0.1)';
          let border = '1px solid rgba(255,255,255,0.2)';
          if (i >= step.left && i <= step.right) {
            bg = 'rgba(79,172,254,0.2)';
            border = '2px solid #4facfe';
          }
          if (i === step.mid) {
            bg = step.comparison === 'equal' ? 'rgba(34,197,94,0.5)' : 'rgba(245,158,66,0.5)';
            border = step.comparison === 'equal' ? '2px solid #22c55e' : '2px solid #f59e42';
          }
          html += `<div style="width:45px;height:45px;background:${bg};border:${border};border-radius:6px;display:flex;align-items:center;justify-content:center;font-size:0.75em;font-weight:bold;">${this.arr[i]}</div>`;
        }
        html += '</div>';
        this.canvas.innerHTML = html;
      }
      
      render() {
        let html = '<div style="display:flex;gap:5px;justify-content:center;align-items:center;height:100%;flex-wrap:wrap;padding:20px;">';
        for (let i = 0; i < this.arr.length; i++) {
          const isTarget = this.arr[i] === this.target;
          html += `<div style="width:45px;height:45px;background:${isTarget ? 'rgba(79,172,254,0.3)' : 'rgba(255,255,255,0.1)'};border:${isTarget ? '2px solid #4facfe' : '1px solid rgba(255,255,255,0.2)'};border-radius:6px;display:flex;align-items:center;justify-content:center;font-size:0.75em;font-weight:bold;">${this.arr[i]}</div>`;
        }
        html += '</div>';
        if (this.target) {
          html += `<div style="text-align:center;margin-top:10px;color:#4facfe;">Target: ${this.target}</div>`;
        }
        this.canvas.innerHTML = html;
      }
      
      reset() {
        this.target = null;
        this.isSearching = false;
        this.canvas.innerHTML = '<div style="display:flex;align-items:center;justify-content:center;height:100%;opacity:0.5;">Click "Set Random Target" to begin</div>';
        document.getElementById('bsearch-output').textContent = '# Click "Set Random Target" to begin...';
      }
    }

    // ========== ANIMATION 2: WAL Demo ==========
    class WALAnimation {
      constructor(canvasId) {
        this.canvas = document.getElementById(canvasId);
        this.entries = [];
        this.index = {};
        this.counter = 0;
      }
      
      appendEntry() {
        const key = `user:${100 + this.counter}`;
        const value = `data_${this.counter}`;
        this.entries.push({ key, value, pos: this.entries.length });
        this.index[key] = this.entries.length - 1;
        this.counter++;
        this.render();
        document.getElementById('wal-status').innerHTML = `<span style="color:#22c55e;">âœ“ Appended ${key} = ${value}</span>`;
      }
      
      lookupKey() {
        if (this.entries.length === 0) return;
        const randomKey = Object.keys(this.index)[Math.floor(Math.random() * Object.keys(this.index).length)];
        const pos = this.index[randomKey];
        const value = this.entries[pos].value;
        document.getElementById('wal-status').innerHTML = `<span style="color:#4facfe;">ğŸ” get("${randomKey}") â†’ "${value}" (index lookup O(1))</span>`;
        this.highlightEntry(pos);
      }
      
      simulateCrash() {
        this.index = {};
        document.getElementById('wal-status').innerHTML = `<span style="color:#ef4444;">ğŸ’¥ CRASH! In-memory index LOST! Must rebuild by scanning ${this.entries.length} entries...</span>`;
        this.render(true);
      }
      
      highlightEntry(pos) {
        this.render();
        const entryDivs = this.canvas.querySelectorAll('.log-entry');
        if (entryDivs[pos]) {
          entryDivs[pos].style.background = 'rgba(79,172,254,0.3)';
          entryDivs[pos].style.borderLeftColor = '#22c55e';
        }
      }
      
      render(crashed = false) {
        let html = '<div style="padding:10px;height:100%;overflow-y:auto;">';
        html += '<div style="font-size:0.7em;color:#8b949e;margin-bottom:10px;">ğŸ“„ wal.log</div>';
        for (let i = 0; i < this.entries.length; i++) {
          const e = this.entries[i];
          html += `<div class="log-entry">${Date.now()}|${e.key}|${e.value}</div>`;
        }
        if (this.entries.length === 0) {
          html += '<div style="opacity:0.5;text-align:center;margin-top:50px;">Log is empty. Click "Append Entry" to add data.</div>';
        }
        html += '</div>';
        if (crashed) {
          html += '<div style="position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(239,68,68,0.9);padding:15px 25px;border-radius:10px;font-weight:bold;">ğŸ’¥ INDEX LOST</div>';
        }
        this.canvas.innerHTML = html;
      }
      
      reset() {
        this.entries = [];
        this.index = {};
        this.counter = 0;
        this.render();
        document.getElementById('wal-status').innerHTML = '';
      }
    }

    // ========== ANIMATION 3: Rebuild Race ==========
    class RebuildAnimation {
      constructor(canvasId) {
        this.canvas = document.getElementById(canvasId);
        this.totalEntries = 1000000;
        this.scanProgress = 0;
        this.sparseProgress = 0;
        this.isRunning = false;
      }
      
      startRebuild() {
        if (this.isRunning) return;
        this.reset();
        this.isRunning = true;
        this.scanProgress = 0;
        
        const interval = setInterval(() => {
          this.scanProgress += 10000;
          this.render();
          if (this.scanProgress >= this.totalEntries) {
            clearInterval(interval);
            this.isRunning = false;
            this.showResult('Full scan: 10,000ms (10 seconds!)', false);
          }
        }, 100);
      }
      
      startSparse() {
        if (this.isRunning) return;
        this.reset();
        this.isRunning = true;
        this.sparseProgress = 0;
        
        const interval = setInterval(() => {
          this.sparseProgress += 1;
          this.render();
          if (this.sparseProgress >= 20) {
            clearInterval(interval);
            this.isRunning = false;
            this.showResult('Sparse index: 20ms (500x faster!)', true);
          }
        }, 50);
      }
      
      showResult(text, success) {
        const result = document.getElementById('rebuild-result');
        result.style.display = 'block';
        result.className = `result-box ${success ? 'success' : 'error'}`;
        result.innerHTML = `<strong>${success ? 'ğŸš€' : 'ğŸŒ'} ${text}</strong>`;
      }
      
      render() {
        const scanPct = (this.scanProgress / this.totalEntries) * 100;
        const sparsePct = (this.sparseProgress / 20) * 100;
        
        this.canvas.innerHTML = `
          <div style="padding:25px;height:100%;display:flex;flex-direction:column;justify-content:center;">
            <div style="margin-bottom:25px;">
              <div style="display:flex;justify-content:space-between;margin-bottom:8px;font-size:0.75em;">
                <span style="color:#ef4444;font-weight:bold;">ğŸ”´ Full Scan O(n)</span>
                <span style="color:#ef4444;">${this.scanProgress.toLocaleString()} / ${this.totalEntries.toLocaleString()}</span>
              </div>
              <div style="width:100%;height:25px;background:rgba(255,255,255,0.1);border-radius:12px;overflow:hidden;">
                <div style="width:${scanPct}%;height:100%;background:linear-gradient(90deg,#ef4444,#f5576c);transition:width 0.1s;"></div>
              </div>
            </div>
            <div>
              <div style="display:flex;justify-content:space-between;margin-bottom:8px;font-size:0.75em;">
                <span style="color:#22c55e;font-weight:bold;">ğŸŸ¢ Sparse Index O(log n)</span>
                <span style="color:#22c55e;">${this.sparseProgress} / 20 block headers</span>
              </div>
              <div style="width:100%;height:25px;background:rgba(255,255,255,0.1);border-radius:12px;overflow:hidden;">
                <div style="width:${sparsePct}%;height:100%;background:linear-gradient(90deg,#22c55e,#4ade80);transition:width 0.05s;"></div>
              </div>
            </div>
          </div>
        `;
      }
      
      reset() {
        this.scanProgress = 0;
        this.sparseProgress = 0;
        this.isRunning = false;
        this.render();
        document.getElementById('rebuild-result').style.display = 'none';
      }
    }

    // ========== ANIMATION 4: Corruption Demo ==========
    class CorruptionAnimation {
      constructor(canvasId) {
        this.canvas = document.getElementById(canvasId);
        this.log = [];
      }
      
      singleWrite() {
        this.log.push('1706234567|user:100|Alice');
        this.log.push('1706234568|user:101|Bob');
        this.log.push('1706234569|user:102|Carol');
        this.render();
        document.getElementById('corrupt-output').textContent = this.log.join('\n');
      }
      
      concurrentWrite() {
        this.log.push('1706234570|user:1031706234570|user:104|Eve');
        this.log.push('|Dave1706234571|user:105|Fr');
        this.log.push('ank');
        this.render(true);
        document.getElementById('corrupt-output').innerHTML = '<span style="color:#ef4444;">' + this.log.join('\n') + '\n\n# ğŸ’¥ CORRUPTED! Entries mangled together!</span>';
      }
      
      render(corrupted = false) {
        let html = '<div style="padding:10px;height:100%;overflow-y:auto;font-family:monospace;font-size:0.7em;">';
        for (const line of this.log) {
          const isCorrupt = line.includes('103170') || line.includes('|Dave') || line === 'ank';
          html += `<div class="log-entry ${isCorrupt ? 'corrupted' : ''}">${line}</div>`;
        }
        html += '</div>';
        this.canvas.innerHTML = html;
      }
      
      reset() {
        this.log = [];
        this.canvas.innerHTML = '<div style="display:flex;align-items:center;justify-content:center;height:100%;opacity:0.5;">Click to simulate writes...</div>';
        document.getElementById('corrupt-output').textContent = 'Log file contents will appear here...';
      }
    }

    // ========== ANIMATION 5: Growth Demo ==========
    class GrowthAnimation {
      constructor(canvasId) {
        this.canvas = document.getElementById(canvasId);
        this.total = 0;
        this.active = 10;
        this.uniqueKeys = 10;
      }
      
      addUpdates() {
        this.total += 100;
        this.uniqueKeys = Math.min(this.uniqueKeys + 5, 50);
        this.active = this.uniqueKeys;
        this.render();
      }
      
      runCompaction() {
        this.total = this.active;
        this.render();
        const result = document.getElementById('growth-waste');
        result.style.color = '#22c55e';
        result.textContent = '0%';
      }
      
      render() {
        const waste = this.total > 0 ? Math.round(((this.total - this.active) / this.total) * 100) : 0;
        document.getElementById('growth-total').textContent = this.total;
        document.getElementById('growth-active').textContent = this.active;
        document.getElementById('growth-waste').textContent = waste + '%';
        document.getElementById('growth-waste').style.color = waste > 50 ? '#ef4444' : waste > 20 ? '#f59e42' : '#22c55e';
        
        let html = '<div style="display:flex;gap:3px;flex-wrap:wrap;padding:15px;justify-content:center;align-items:center;height:100%;">';
        const displayCount = Math.min(this.total, 200);
        for (let i = 0; i < displayCount; i++) {
          const isActive = i < this.active;
          html += `<div style="width:12px;height:12px;border-radius:2px;background:${isActive ? '#22c55e' : '#ef4444'};opacity:${isActive ? 1 : 0.3};"></div>`;
        }
        if (this.total > 200) {
          html += `<div style="padding:5px;opacity:0.5;">+${this.total - 200} more...</div>`;
        }
        html += '</div>';
        this.canvas.innerHTML = html;
      }
      
      reset() {
        this.total = 0;
        this.active = 10;
        this.uniqueKeys = 10;
        this.render();
        this.canvas.innerHTML = '<div style="display:flex;align-items:center;justify-content:center;height:100%;opacity:0.5;">Click "Add 100 Updates" to simulate growth...</div>';
      }
    }

    // ========== ANIMATION 6: SSTable Search ==========
    class SSTableAnimation {
      constructor(canvasId) {
        this.canvas = document.getElementById(canvasId);
        this.blocks = ['aaa-dog', 'dog-fox', 'fox-moo', 'moo-rat', 'rat-zoo'];
        this.sparseIndex = ['aaa', 'dog', 'fox', 'moo', 'rat'];
        this.target = null;
      }
      
      setTarget() {
        const keys = ['ant', 'cat', 'duck', 'frog', 'giraffe', 'lion', 'mouse', 'panda', 'snake', 'wolf'];
        this.target = keys[Math.floor(Math.random() * keys.length)];
        this.render();
      }
      
      async runSearch() {
        if (!this.target) return;
        
        // Step 1: Binary search sparse index
        let targetBlock = 0;
        for (let i = this.sparseIndex.length - 1; i >= 0; i--) {
          await this.highlightIndex(i);
          await new Promise(r => setTimeout(r, 400));
          if (this.sparseIndex[i] <= this.target) {
            targetBlock = i;
            break;
          }
        }
        
        // Step 2: Scan block
        await this.highlightBlock(targetBlock);
        
        const result = document.getElementById('sstable-result');
        result.style.display = 'block';
        result.className = 'result-box success';
        result.innerHTML = `<strong>âœ… Found in Block ${targetBlock}!</strong> Binary searched index (${this.sparseIndex.length} entries), then scanned 1 block.`;
      }
      
      async highlightIndex(idx) {
        this.render();
        const indexDivs = this.canvas.querySelectorAll('.index-entry');
        if (indexDivs[idx]) {
          indexDivs[idx].style.background = 'rgba(79,172,254,0.5)';
          indexDivs[idx].style.borderColor = '#4facfe';
        }
      }
      
      async highlightBlock(idx) {
        this.render();
        const blockDivs = this.canvas.querySelectorAll('.block-div');
        if (blockDivs[idx]) {
          blockDivs[idx].style.background = 'rgba(34,197,94,0.5)';
          blockDivs[idx].style.borderColor = '#22c55e';
        }
      }
      
      render() {
        let html = '<div style="padding:15px;">';
        html += '<div style="font-size:0.7em;color:#8b949e;margin-bottom:8px;">SPARSE INDEX (in memory)</div>';
        html += '<div style="display:flex;gap:8px;margin-bottom:20px;">';
        for (let i = 0; i < this.sparseIndex.length; i++) {
          html += `<div class="index-entry" style="padding:8px 15px;background:rgba(79,172,254,0.2);border:1px solid #4facfe;border-radius:4px;font-size:0.75em;">"${this.sparseIndex[i]}" â†’ Block ${i}</div>`;
        }
        html += '</div>';
        html += '<div style="font-size:0.7em;color:#8b949e;margin-bottom:8px;">DATA BLOCKS (on disk)</div>';
        html += '<div style="display:flex;gap:8px;">';
        for (let i = 0; i < this.blocks.length; i++) {
          html += `<div class="block-div" style="padding:15px;background:rgba(255,255,255,0.1);border:1px solid rgba(255,255,255,0.2);border-radius:6px;font-size:0.7em;text-align:center;flex:1;">Block ${i}<br><span style="opacity:0.7;font-size:0.9em;">${this.blocks[i]}</span></div>`;
        }
        html += '</div>';
        if (this.target) {
          html += `<div style="margin-top:15px;text-align:center;color:#f59e42;">ğŸ¯ Target: "${this.target}"</div>`;
        }
        html += '</div>';
        this.canvas.innerHTML = html;
      }
      
      reset() {
        this.target = null;
        this.render();
        document.getElementById('sstable-result').style.display = 'none';
      }
    }

    // ========== ANIMATION 7: Compaction Demo ==========
    class CompactionAnimation {
      constructor(canvasId) {
        this.canvas = document.getElementById(canvasId);
        this.segments = [];
        this.totalEntries = 0;
      }
      
      addSegments() {
        for (let i = 0; i < 3; i++) {
          const entries = 20 + Math.floor(Math.random() * 30);
          this.segments.push({ id: this.segments.length, entries, color: this.getColor(this.segments.length) });
          this.totalEntries += entries;
        }
        this.render();
      }
      
      runCompaction() {
        if (this.segments.length < 3) return;
        
        const last3 = this.segments.slice(-3);
        const mergedEntries = Math.floor(last3.reduce((sum, s) => sum + s.entries, 0) * 0.6); // 40% reduction
        
        this.segments = this.segments.slice(0, -3);
        this.segments.push({ id: 'C', entries: mergedEntries, color: '#22c55e' });
        this.totalEntries = this.segments.reduce((sum, s) => sum + s.entries, 0);
        this.render();
      }
      
      getColor(idx) {
        const colors = ['#4facfe', '#8957ff', '#f59e42', '#ef4444', '#22c55e', '#06b6d4'];
        return colors[idx % colors.length];
      }
      
      render() {
        document.getElementById('compact-count').textContent = this.segments.length;
        document.getElementById('compact-entries').textContent = this.totalEntries;
        
        let html = '<div style="display:flex;gap:10px;padding:20px;justify-content:center;align-items:end;height:100%;">';
        for (const seg of this.segments) {
          const height = Math.max(30, seg.entries * 2);
          html += `<div style="width:60px;height:${height}px;background:${seg.color};border-radius:6px;display:flex;flex-direction:column;align-items:center;justify-content:center;font-size:0.7em;color:#fff;">
            <div style="font-weight:bold;">Seg ${seg.id}</div>
            <div>${seg.entries}</div>
          </div>`;
        }
        html += '</div>';
        this.canvas.innerHTML = html;
      }
      
      reset() {
        this.segments = [];
        this.totalEntries = 0;
        this.render();
        this.canvas.innerHTML = '<div style="display:flex;align-items:center;justify-content:center;height:100%;opacity:0.5;">Click "Add 3 Segments" to begin...</div>';
      }
    }

    // ========== ANIMATION 8: Index Building Demo ==========
    class IndexBuildAnimation {
      constructor(canvasId) {
        this.canvas = document.getElementById(canvasId);
        this.memtableData = [
          { key: 'aardvark', value: 'v1' },
          { key: 'bear', value: 'v2' },
          { key: 'cat', value: 'v3' },
          { key: 'dog', value: 'v4' },
          { key: 'elephant', value: 'v5' },
          { key: 'fox', value: 'v6' },
          { key: 'giraffe', value: 'v7' },
          { key: 'hippo', value: 'v8' },
          { key: 'iguana', value: 'v9' },
          { key: 'jaguar', value: 'v10' },
          { key: 'koala', value: 'v11' },
          { key: 'lion', value: 'v12' }
        ];
        this.currentEntry = 0;
        this.sparseIndex = [];
        this.currentBlock = [];
        this.blocks = [];
        this.isRunning = false;
      }
      
      async startFlush() {
        if (this.isRunning) return;
        this.reset();
        this.isRunning = true;
        
        const status = document.getElementById('indexbuild-status');
        status.innerHTML = '<span style="color:#f59e42;">ğŸ”„ Flushing memtable to SSTable...</span>';
        
        for (let i = 0; i < this.memtableData.length; i++) {
          this.currentEntry = i;
          const entry = this.memtableData[i];
          
          // First entry of block? Record in sparse index
          if (this.currentBlock.length === 0) {
            this.sparseIndex.push({ key: entry.key, blockNum: this.blocks.length });
          }
          
          this.currentBlock.push(entry);
          
          // Block full (4 entries for demo)?
          if (this.currentBlock.length >= 4) {
            this.blocks.push([...this.currentBlock]);
            this.currentBlock = [];
          }
          
          this.render();
          await new Promise(r => setTimeout(r, 300));
        }
        
        // Final partial block
        if (this.currentBlock.length > 0) {
          this.blocks.push([...this.currentBlock]);
          this.currentBlock = [];
        }
        
        this.render();
        this.isRunning = false;
        status.innerHTML = '<span style="color:#22c55e;">âœ… SSTable created! Sparse index has ' + this.sparseIndex.length + ' entries for ' + this.blocks.length + ' blocks.</span>';
      }
      
      render() {
        let html = '<div style="display:flex;gap:20px;padding:15px;height:100%;">';
        
        // Memtable side
        html += '<div style="flex:1;border-right:1px solid rgba(255,255,255,0.2);padding-right:15px;">';
        html += '<div style="font-size:0.7em;color:#8b949e;margin-bottom:8px;">ğŸ“ MEMTABLE (sorted)</div>';
        html += '<div style="display:flex;flex-wrap:wrap;gap:4px;">';
        for (let i = 0; i < this.memtableData.length; i++) {
          const e = this.memtableData[i];
          const isProcessed = i < this.currentEntry;
          const isCurrent = i === this.currentEntry && this.isRunning;
          html += '<div style="padding:4px 8px;border-radius:4px;font-size:0.65em;background:${isProcessed ? "rgba(34,197,94,0.3)" : isCurrent ? "rgba(245,158,66,0.5)" : "rgba(79,172,254,0.2)"};border:1px solid ${isProcessed ? "#22c55e" : isCurrent ? "#f59e42" : "#4facfe"};opacity:${isProcessed ? 0.5 : 1};">${e.key}</div>'.replace(/\${isProcessed \? [^}]+}/g, m => eval(m.slice(2, -1)));
        }
        html += '</div></div>';
        
        // SSTable side
        html += '<div style="flex:2;">';
        html += '<div style="font-size:0.7em;color:#8b949e;margin-bottom:8px;">ğŸ’¾ SSTABLE (blocks)</div>';
        
        // Sparse Index
        html += '<div style="margin-bottom:10px;padding:8px;background:rgba(136,87,255,0.2);border:1px solid #8957ff;border-radius:6px;">';
        html += '<div style="font-size:0.6em;color:#8957ff;margin-bottom:5px;">SPARSE INDEX</div>';
        html += '<div style="display:flex;gap:8px;flex-wrap:wrap;">';
        for (const idx of this.sparseIndex) {
          html += '<div style="padding:3px 8px;background:rgba(136,87,255,0.3);border-radius:4px;font-size:0.6em;">"${idx.key}" â†’ Block ${idx.blockNum}</div>'.replace(/\${idx\.[^}]+}/g, m => eval(m.slice(2, -1)));
        }
        if (this.sparseIndex.length === 0) {
          html += '<span style="opacity:0.5;font-size:0.6em;">Building...</span>';
        }
        html += '</div></div>';
        
        // Blocks
        html += '<div style="display:flex;gap:8px;flex-wrap:wrap;">';
        for (let b = 0; b < this.blocks.length; b++) {
          html += '<div style="padding:8px;background:rgba(34,197,94,0.2);border:1px solid #22c55e;border-radius:6px;min-width:100px;">';
          html += '<div style="font-size:0.6em;color:#22c55e;margin-bottom:4px;">Block ' + b + '</div>';
          for (const e of this.blocks[b]) {
            html += '<div style="font-size:0.55em;opacity:0.8;">' + e.key + '</div>';
          }
          html += '</div>';
        }
        
        // Current block being built
        if (this.currentBlock.length > 0) {
          html += '<div style="padding:8px;background:rgba(245,158,66,0.2);border:2px dashed #f59e42;border-radius:6px;min-width:100px;">';
          html += '<div style="font-size:0.6em;color:#f59e42;margin-bottom:4px;">Building...</div>';
          for (const e of this.currentBlock) {
            html += '<div style="font-size:0.55em;opacity:0.8;">' + e.key + '</div>';
          }
          html += '</div>';
        }
        html += '</div></div></div>';
        
        this.canvas.innerHTML = html;
      }
      
      reset() {
        this.currentEntry = 0;
        this.sparseIndex = [];
        this.currentBlock = [];
        this.blocks = [];
        this.isRunning = false;
        this.canvas.innerHTML = '<div style="display:flex;align-items:center;justify-content:center;height:100%;opacity:0.5;">Click "â–¶ï¸ Flush Memtable â†’ SSTable" to see index building...</div>';
        document.getElementById('indexbuild-status').innerHTML = '';
      }
    }

    // ========== ANIMATION 9: Tombstone Lifecycle Demo ==========
    class TombstoneAnimation {
      constructor(canvasId) {
        this.canvas = document.getElementById(canvasId);
        this.sstables = [];
        this.step = 0;
      }
      
      writeData() {
        this.sstables = [{ id: 1, entries: [{ key: 'user:100', value: 'Alice', type: 'data' }] }];
        this.step = 1;
        this.render();
        document.getElementById('tombstone-status').innerHTML = '<span style="color:#22c55e;">âœ… Step 1: Written user:100 â†’ "Alice" to SSTable #1</span>';
      }
      
      deleteData() {
        if (this.step < 1) return;
        this.sstables.unshift({ id: 2, entries: [{ key: 'user:100', value: 'âš°ï¸ TOMBSTONE', type: 'tombstone' }] });
        this.step = 2;
        this.render();
        document.getElementById('tombstone-status').innerHTML = '<span style="color:#ef4444;">ğŸ—‘ï¸ Step 2: Delete creates TOMBSTONE in NEW SSTable #2. Original data still in SSTable #1!</span>';
      }
      
      readData() {
        if (this.step < 2) return;
        this.step = 3;
        this.render();
        document.getElementById('tombstone-status').innerHTML = '<span style="color:#4facfe;">ğŸ” Step 3: Read checks newest first â†’ finds TOMBSTONE â†’ returns NULL (deleted)</span>';
      }
      
      runCompaction() {
        if (this.step < 3) return;
        this.sstables = [{ id: 'C', entries: [], compacted: true }];
        this.step = 4;
        this.render();
        document.getElementById('tombstone-status').innerHTML = '<span style="color:#22c55e;">ğŸ”„ Step 4: Compaction merges & removes tombstones. Space finally reclaimed!</span>';
      }
      
      render() {
        let html = '<div style="display:flex;gap:15px;padding:15px;height:100%;align-items:center;justify-content:center;">';
        
        for (const sst of this.sstables) {
          const isNew = sst.id === 2;
          const isCompacted = sst.compacted;
          const bgColor = isCompacted ? 'rgba(34,197,94,0.2)' : isNew ? 'rgba(239,68,68,0.2)' : 'rgba(79,172,254,0.2)';
          const borderColor = isCompacted ? '#22c55e' : isNew ? '#ef4444' : '#4facfe';
          
          html += '<div style="padding:15px 20px;background:' + bgColor + ';border:2px solid ' + borderColor + ';border-radius:10px;min-width:140px;text-align:center;">';
          html += '<div style="font-weight:bold;margin-bottom:10px;color:' + borderColor + ';">SSTable #' + sst.id + '</div>';
          
          if (isCompacted) {
            html += '<div style="font-size:0.75em;color:#22c55e;">âœ¨ Empty!</div>';
            html += '<div style="font-size:0.6em;opacity:0.7;margin-top:5px;">user:100 removed</div>';
          } else {
            for (const entry of sst.entries) {
              const isTombstone = entry.type === 'tombstone';
              const highlight = this.step === 3 && sst.id === 2;
              html += '<div style="padding:6px 10px;margin:5px 0;border-radius:4px;font-size:0.7em;background:' + (isTombstone ? 'rgba(239,68,68,0.3)' : 'rgba(34,197,94,0.3)') + ';border:' + (highlight ? '2px solid #f59e42' : '1px solid ' + (isTombstone ? '#ef4444' : '#22c55e')) + ';">';
              html += '<div style="font-weight:bold;">' + entry.key + '</div>';
              html += '<div style="font-size:0.9em;opacity:0.9;">' + entry.value + '</div>';
              html += '</div>';
            }
          }
          html += '</div>';
          
          if (this.sstables.indexOf(sst) < this.sstables.length - 1) {
            html += '<div style="font-size:1.5em;color:#8b949e;">â†</div>';
          }
        }
        
        if (this.step === 3) {
          html += '<div style="margin-left:20px;padding:15px;background:rgba(245,158,66,0.2);border:2px solid #f59e42;border-radius:10px;">';
          html += '<div style="font-size:0.8em;color:#f59e42;">ğŸ” Read Result</div>';
          html += '<div style="font-size:1.2em;font-weight:bold;color:#ef4444;margin-top:5px;">NULL</div>';
          html += '<div style="font-size:0.65em;opacity:0.8;">(tombstone found)</div>';
          html += '</div>';
        }
        
        html += '</div>';
        this.canvas.innerHTML = html;
      }
      
      reset() {
        this.sstables = [];
        this.step = 0;
        this.canvas.innerHTML = '<div style="display:flex;align-items:center;justify-content:center;height:100%;opacity:0.5;">Click buttons 1â†’2â†’3â†’4 to see tombstone lifecycle...</div>';
        document.getElementById('tombstone-status').innerHTML = '';
      }
    }

    // ========== ANIMATION 10: Engineering Layers ==========
    class LayersAnimation {
      constructor(canvasId) {
        this.canvas = document.getElementById(canvasId);
        this.layers = [
          { name: 'Binary Search Core', color: '#667eea', lines: '15 lines' },
          { name: 'Memtable + WAL', color: '#764ba2', lines: '+50 lines' },
          { name: 'SSTable Segments', color: '#f093fb', lines: '+100 lines' },
          { name: 'Compaction', color: '#4facfe', lines: '+75 lines' },
          { name: 'Concurrency', color: '#00f2fe', lines: '+60 lines' },
          { name: 'Monitoring', color: '#22c55e', lines: '+40 lines' }
        ];
        this.currentLayer = 0;
        this.isAnimating = false;
      }
      
      startAnimation() {
        if (this.isAnimating) return;
        this.reset();
        this.isAnimating = true;
        this.currentLayer = 0;
        this.animateNextLayer();
      }
      
      animateNextLayer() {
        if (!this.isAnimating || this.currentLayer >= this.layers.length) {
          this.isAnimating = false;
          return;
        }
        const layer = this.layers[this.currentLayer];
        const layerEl = document.createElement('div');
        const yPos = 200 - (this.currentLayer + 1) * 35;
        layerEl.style.cssText = `position:absolute;left:50%;transform:translateX(-50%);top:${yPos}px;width:80%;max-width:500px;height:30px;background:linear-gradient(135deg,${layer.color},${layer.color}dd);border:1px solid rgba(255,255,255,0.3);border-radius:6px;opacity:0;animation:fadeIn 0.5s ease forwards;display:flex;align-items:center;justify-content:space-between;padding:0 15px;color:#fff;font-size:0.75em;box-shadow:0 4px 15px rgba(0,0,0,0.3);`;
        layerEl.innerHTML = `<span style="font-weight:bold;">${layer.name}</span><span style="opacity:0.8;">${layer.lines}</span>`;
        this.canvas.appendChild(layerEl);
        this.currentLayer++;
        setTimeout(() => this.animateNextLayer(), 600);
      }
      
      reset() {
        this.currentLayer = 0;
        this.isAnimating = false;
        this.canvas.innerHTML = '<div style="display:flex;align-items:center;justify-content:center;height:100%;opacity:0.5;">Click "Watch Evolution" to see the layers build up...</div>';
      }
    }

    // ========== INITIALIZE ==========
    let bsearchAnim, walAnim, rebuildAnim, corruptAnim, growthAnim, sstableAnim, compactAnim, indexBuildAnim, tombstoneAnim, layersAnim;
    
    Reveal.initialize({
      hash: true,
      slideNumber: 'c/t',
      showSlideNumber: 'all',
      transition: 'slide',
      transitionSpeed: 'default',
      backgroundTransition: 'fade',
      plugins: [RevealHighlight, RevealNotes],
      navigationMode: 'default',
      progress: true,
      controls: true,
      center: true,
      keyboard: true,
      width: 1920,
      height: 1080,
      margin: 0.04,
      minScale: 0.2,
      maxScale: 1.0
    });

    Reveal.on('ready', () => {
      bsearchAnim = new BinarySearchAnimation('canvas-bsearch');
      walAnim = new WALAnimation('canvas-wal');
      rebuildAnim = new RebuildAnimation('canvas-rebuild');
      corruptAnim = new CorruptionAnimation('canvas-corrupt');
      growthAnim = new GrowthAnimation('canvas-growth');
      sstableAnim = new SSTableAnimation('canvas-sstable');
      compactAnim = new CompactionAnimation('canvas-compact');
      indexBuildAnim = new IndexBuildAnimation('canvas-indexbuild');
      tombstoneAnim = new TombstoneAnimation('canvas-tombstone');
      layersAnim = new LayersAnimation('canvas-layers');
      
      // Initialize all canvases
      bsearchAnim.reset();
      walAnim.reset();
      rebuildAnim.reset();
      corruptAnim.reset();
      growthAnim.reset();
      sstableAnim.render();
      compactAnim.reset();
      indexBuildAnim.reset();
      tombstoneAnim.reset();
      layersAnim.reset();
    });
  </script>
</body>
</html>
