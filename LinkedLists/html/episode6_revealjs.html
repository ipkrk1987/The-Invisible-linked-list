<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Episode 6: Distributed Caches at Scale ‚Äì When One Server Isn't Enough</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.5.0/reset.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.5.0/reveal.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.5.0/theme/black.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/monokai.min.css">
    <style>
        :root {
            --primary: #4facfe;
            --secondary: #00f2fe;
            --accent: #f093fb;
            --warning: #ffeaa7;
            --danger: #ff6b6b;
            --success: #00b894;
            --bg-dark: #1a1a2e;
        }
        .reveal {
            font-family: 'Segoe UI', system-ui, sans-serif;
        }
        .reveal h1, .reveal h2, .reveal h3 {
            text-transform: none;
            font-weight: 700;
        }
        .reveal h1 {
            font-size: 1.1em;
            background: linear-gradient(90deg, var(--primary), var(--secondary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        .reveal h2 {
            font-size: 0.85em;
            color: var(--primary);
        }
        .reveal h3 {
            font-size: 0.75em;
            color: var(--secondary);
        }
        .reveal pre {
            width: 100%;
            font-size: 0.55em;
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
            border-radius: 12px;
        }
        .reveal code {
            font-family: 'Fira Code', 'Consolas', monospace;
        }
        .disaster-text {
            color: var(--danger);
            font-size: 1.2em;
            font-weight: 800;
        }
        .gradient-text {
            background: linear-gradient(90deg, var(--primary), var(--secondary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        .highlight-box {
            background: rgba(79, 172, 254, 0.1);
            border: 2px solid var(--primary);
            border-radius: 8px;
            padding: 8px;
            margin: 6px 0;
            font-size: 0.55em;
        }
        .warning-box {
            background: rgba(255, 107, 107, 0.1);
            border: 2px solid var(--danger);
            border-radius: 8px;
            padding: 8px;
            margin: 6px 0;
            font-size: 0.55em;
        }
        .success-box {
            background: rgba(0, 184, 148, 0.1);
            border: 2px solid var(--success);
            border-radius: 8px;
            padding: 8px;
            margin: 6px 0;
            font-size: 0.55em;
        }
        .disaster-box {
            background: rgba(255, 107, 107, 0.2);
            border: 3px solid var(--danger);
            border-radius: 8px;
            padding: 10px;
            margin: 6px 0;
            font-size: 0.55em;
        }
        .stat-number {
            font-size: 1.3em;
            font-weight: 800;
            background: linear-gradient(90deg, var(--danger), var(--warning));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        .pyramid {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }
        .pyramid-level {
            background: linear-gradient(90deg, var(--primary), var(--secondary));
            color: #000;
            padding: 10px 20px;
            border-radius: 4px;
            font-weight: 600;
            font-size: 0.75em;
        }
        .pyramid-level:nth-child(1) { width: 35%; }
        .pyramid-level:nth-child(2) { width: 50%; }
        .pyramid-level:nth-child(3) { width: 65%; }
        .badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.7em;
            font-weight: 600;
            margin: 0 5px;
        }
        .badge-blue { background: var(--primary); color: #000; }
        .badge-green { background: var(--success); color: #000; }
        .badge-red { background: var(--danger); color: #fff; }
        .badge-yellow { background: var(--warning); color: #000; }
        blockquote {
            background: rgba(79, 172, 254, 0.1);
            border-left: 4px solid var(--primary);
            padding: 20px;
            font-style: italic;
            border-radius: 0 12px 12px 0;
            font-size: 0.8em;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.65em;
        }
        th, td {
            padding: 10px;
            text-align: left;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        th {
            background: rgba(79, 172, 254, 0.2);
            color: var(--primary);
        }
        .two-column {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            align-items: start;
        }
        .pseudo-code {
            background: rgba(79, 172, 254, 0.08);
            border-left: 4px solid var(--secondary);
            padding: 15px 20px;
            border-radius: 0 12px 12px 0;
            font-family: 'Fira Code', monospace;
            font-size: 0.65em;
            margin: 15px 0;
            text-align: left;
        }
        .repo-link {
            background: rgba(0, 184, 148, 0.2);
            border: 1px solid var(--success);
            border-radius: 8px;
            padding: 10px 15px;
            font-size: 0.7em;
            margin-top: 15px;
        }
        .repo-link a {
            color: var(--success);
            text-decoration: none;
        }
        .ring-diagram {
            font-family: 'Fira Code', monospace;
            font-size: 0.7em;
            background: rgba(79, 172, 254, 0.05);
            padding: 20px;
            border-radius: 12px;
            text-align: center;
        }
        .timeline {
            text-align: left;
            font-family: 'Fira Code', monospace;
            font-size: 0.6em;
            background: rgba(255, 107, 107, 0.1);
            padding: 15px 20px;
            border-radius: 8px;
            border-left: 4px solid var(--danger);
        }
        .insight-box {
            background: rgba(0, 242, 254, 0.1);
            border: 2px solid var(--secondary);
            border-radius: 8px;
            padding: 15px;
            margin: 10px 0;
            font-size: 0.6em;
        }
        .company-logos {
            display: flex;
            justify-content: space-around;
            flex-wrap: wrap;
            gap: 15px;
            margin-top: 15px;
        }
        .company-item {
            background: rgba(79, 172, 254, 0.1);
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 0.65em;
        }
        .episode-list {
            text-align: left;
            font-size: 0.6em;
            line-height: 1.8;
        }
        .episode-list .current {
            color: var(--secondary);
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="reveal">
        <div class="slides">

            <!-- ==================== SLIDE 1: TITLE ==================== -->
            <section>
                <h1>Episode 6: Distributed Caches at Scale</h1>
                <h2>When One Server Isn't Enough</h2>
                <p style="font-size: 0.6em; color: var(--secondary); margin-top: 30px;">
                    Season 1: The Invisible Linked List
                </p>
                <p style="font-size: 0.5em; opacity: 0.7; margin-top: 20px;">
                    üåê From single-machine LRU to global CDNs
                </p>
            </section>

            <!-- ==================== ACT 1: THE 99% DISASTER ==================== -->

            <!-- SLIDE 2: The Scene -->
            <section>
                <h2>üî• 3:47 AM ‚Äî The Incident</h2>
                <div class="disaster-box">
                    <pre style="background: transparent; box-shadow: none; margin: 0; font-size: 1em;">
üî• INCIDENT: Cache cluster expansion
   Time: 3:47 AM
   Action: Added 1 server to 100-server cluster
   Result: <span class="disaster-text">DATABASE DOWN</span></pre>
                </div>
                <p style="font-size: 0.8em; margin-top: 20px;">
                    You added <span class="disaster-text">ONE</span> server. Everything broke.
                </p>
            </section>

            <!-- SLIDE 3: What Happened? -->
            <section>
                <h2>What Happened?</h2>
                <h3>The Naive Approach</h3>
                <pre><code class="language-python">server = hash(key) % num_servers

# Before (100 servers):
hash("user:123") % 100 = 42  ‚Üí Server 42 ‚úì

# After (101 servers):
hash("user:123") % 101 = 87  ‚Üí Server 87 ‚úó

# Key moved! Cache miss! Database query!</code></pre>
                <p class="fragment" style="font-size: 0.7em; color: var(--danger);">
                    Every key rehashes to a different server!
                </p>
            </section>

            <!-- SLIDE 4: The Math That Killed Us -->
            <section>
                <h2>The Math That Killed Us</h2>
                <table>
                    <tr>
                        <th>Servers</th>
                        <th>Keys That Move</th>
                        <th>Cache Misses</th>
                    </tr>
                    <tr>
                        <td>100 ‚Üí 101</td>
                        <td class="disaster-text">99%</td>
                        <td>99 million</td>
                    </tr>
                    <tr>
                        <td>100 ‚Üí 102</td>
                        <td class="disaster-text">98%</td>
                        <td>98 million</td>
                    </tr>
                </table>
                <p class="fragment" style="font-size: 0.8em; margin-top: 20px;">
                    Adding <span class="stat-number">ONE</span> server invalidated 
                    <span class="stat-number">99%</span> of your cache.
                </p>
            </section>

            <!-- SLIDE 5: The Death Spiral -->
            <section>
                <h2>The Death Spiral</h2>
                <div class="timeline">
                    <p>3:47:00 AM ‚Äî Server 101 joins cluster</p>
                    <p>3:47:01 AM ‚Äî 99M keys now "missing"</p>
                    <p>3:47:02 AM ‚Äî 99M database queries begin</p>
                    <p>3:47:05 AM ‚Äî Database connection pool exhausted</p>
                    <p>3:47:10 AM ‚Äî <span style="color: var(--danger);">Site down, revenue: $0</span></p>
                </div>
                <p class="fragment" style="font-size: 0.75em; margin-top: 25px; color: var(--secondary);">
                    How do we add servers <em>without</em> this chaos?
                </p>
            </section>

            <!-- ==================== ACT 2: THE RING INSIGHT ==================== -->

            <!-- SLIDE 6: The Key Idea -->
            <section>
                <h2>üí° The Key Idea: Hash Ring</h2>
                <div class="insight-box">
                    <p><strong>Instead of:</strong> <code>hash(key) % N</code></p>
                    <p style="margin-top: 10px;"><strong>Use:</strong></p>
                    <p><code>hash(key) ‚Üí position on a RING</code></p>
                    <p><code>Key goes to first server CLOCKWISE</code></p>
                </div>
                <p class="fragment" style="font-size: 0.7em; margin-top: 20px;">
                    A <span class="gradient-text">circular linked structure</span>!
                </p>
            </section>

            <!-- SLIDE 7: Hash Ring Visualization -->
            <section>
                <h2>Hash Ring Visualization</h2>
                <div class="ring-diagram">
                    <pre style="background: transparent; box-shadow: none;">
           0¬∞
      ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
      ‚îÇ    A    ‚îÇ   ‚óè Server A at 45¬∞
  270¬∞‚îÇ         ‚îÇ90¬∞ ‚óÜ Server B at 180¬∞
      ‚îÇ    B    ‚îÇ   ‚òÖ Key X at 75¬∞
      ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
          180¬∞

‚òÖ Key X ‚Üí walks clockwise ‚Üí hits Server B</pre>
                </div>
                <p style="font-size: 0.7em; margin-top: 15px; color: var(--secondary);">
                    Rule: Walk <strong>clockwise</strong> from key's position until you hit a server.
                </p>
            </section>

            <!-- SLIDE 8: Adding a Server (The Magic) -->
            <section>
                <h2>Adding a Server: The Magic</h2>
                <div class="two-column" style="font-size: 0.7em;">
                    <div>
                        <h3>Before</h3>
                        <p>A at 45¬∞</p>
                        <p>B at 180¬∞</p>
                    </div>
                    <div>
                        <h3>After (add C at 120¬∞)</h3>
                        <p>A at 45¬∞</p>
                        <p style="color: var(--success);">C at 120¬∞ ‚Üê NEW</p>
                        <p>B at 180¬∞</p>
                    </div>
                </div>
                <div class="success-box" style="margin-top: 20px;">
                    <p><strong>What moves?</strong></p>
                    <p>‚Ä¢ Keys between 45¬∞-120¬∞ move from B ‚Üí C</p>
                    <p>‚Ä¢ Everything else <strong>stays put!</strong></p>
                    <p>‚Ä¢ Only <span style="color: var(--success);">~33%</span> keys move (not 99%)</p>
                </div>
            </section>

            <!-- SLIDE 9: The Math That Saves Us -->
            <section>
                <h2>The Math That Saves Us</h2>
                <table>
                    <tr>
                        <th>Method</th>
                        <th>Keys That Move</th>
                    </tr>
                    <tr>
                        <td>hash % N</td>
                        <td class="disaster-text">99%</td>
                    </tr>
                    <tr>
                        <td style="color: var(--success);">Consistent Hashing</td>
                        <td style="color: var(--success);">~1/N (~1%)</td>
                    </tr>
                </table>
                <p class="fragment" style="font-size: 0.75em; margin-top: 25px;">
                    From <span class="disaster-text">99 million</span> cache misses to 
                    <span style="color: var(--success);">1 million</span>.<br>
                    <em>That's the difference between a crash and a smooth deployment.</em>
                </p>
            </section>

            <!-- ==================== ACT 3: BUILDING CONSISTENT HASHING ==================== -->

            <!-- SLIDE 10: The Algorithm (Pseudocode) -->
            <section>
                <h2>Consistent Hashing: The Algorithm</h2>
                <div class="pseudo-code">
<pre>HASH RING STRUCTURE:
  ring = sorted circular list of (hash_position, server_id)

ADD_SERVER(server):
  position = hash(server)
  insert into ring at position

GET_SERVER(key):
  position = hash(key)
  walk clockwise until first server
  return that server

REMOVE_SERVER(server):
  remove from ring
  keys automatically route to next server clockwise</pre>
                </div>
            </section>

            <!-- SLIDE 11: Python Implementation -->
            <section>
                <h2>Python Implementation</h2>
                <pre><code class="language-python">class ConsistentHashRing:
    def __init__(self):
        self.ring = {}          # hash -> server_id
        self.sorted_keys = []   # for binary search
    
    def add_server(self, server_id):
        h = self._hash(server_id)
        self.ring[h] = server_id
        self.sorted_keys = sorted(self.ring.keys())
    
    def get_server(self, key):
        h = self._hash(key)
        # Binary search for first hash >= key hash
        for server_hash in self.sorted_keys:
            if server_hash >= h:
                return self.ring[server_hash]
        return self.ring[self.sorted_keys[0]]  # wrap around</code></pre>
                <div class="repo-link">
                    üìÅ Full implementation: <a href="#">github.com/repo/consistent-hashing</a>
                </div>
            </section>

            <!-- SLIDE 12: The Virtual Nodes Trick -->
            <section>
                <h2>The Virtual Nodes Trick</h2>
                <div class="warning-box">
                    <p><strong>Problem:</strong> What if servers hash to nearby positions? Uneven load!</p>
                </div>
                <div class="success-box" style="margin-top: 15px;">
                    <p><strong>Solution:</strong> Each server gets 100+ positions on the ring</p>
                </div>
                <pre><code class="language-python">def add_server(self, server_id, virtual_nodes=100):
    for i in range(virtual_nodes):
        h = self._hash(f"{server_id}-{i}")
        self.ring[h] = server_id</code></pre>
                <p class="fragment" style="font-size: 0.7em; margin-top: 15px;">
                    Result: <span class="gradient-text">Even distribution</span>, handles hot spots
                </p>
            </section>

            <!-- SLIDE 13: DynamoDB Deep Dive -->
            <section>
                <h2>üî∂ Case Study: Amazon DynamoDB</h2>
                <pre><code class="language-python"># DynamoDB partition key ‚Üí consistent hash
# Each partition: 10GB storage, 3000 RCU, 1000 WCU

table.put_item(
    TableName='Users',
    Item={
        'user_id': '12345',      # ‚Üê PARTITION KEY (hashed)
        'email': 'alice@example.com',
        'created': '2024-01-15'
    }
)

# user_id hashed ‚Üí lands on specific partition
# partition_key = hash(user_id) % num_partitions
# BUT: uses consistent hashing internally!</code></pre>
                <p class="fragment" style="font-size: 0.65em; margin-top: 15px;">
                    <span class="gradient-text">10+ trillion requests/day</span> across millions of partitions
                </p>
            </section>

            <!-- SLIDE 14: Cassandra Token Ring -->
            <section>
                <h2>üîµ Case Study: Cassandra Token Ring</h2>
                <pre><code class="language-sql">-- Cassandra uses Murmur3 hash (2^64 token range)
-- Each node owns a range of tokens

CREATE TABLE users (
    user_id UUID PRIMARY KEY,  -- hashed to token
    name TEXT,
    email TEXT
);

-- Token assignment (nodetool ring):
-- Node A: -9223372036854775808 to -3074457345618258603
-- Node B: -3074457345618258602 to  3074457345618258602  
-- Node C:  3074457345618258603 to  9223372036854775807</code></pre>
                <div class="highlight-box" style="margin-top: 10px;">
                    <strong>Virtual Nodes (vnodes):</strong> Each node owns 256 token ranges by default
                </div>
            </section>

            <!-- SLIDE 15: Discord Guild Sharding -->
            <section>
                <h2>üéÆ Case Study: Discord Guild Sharding</h2>
                <pre><code class="language-python"># Discord: 19M+ concurrent users, 6.7M active servers

def get_shard(guild_id: int, num_shards: int) -> int:
    # Simple modulo for guild ‚Üí shard mapping
    return (guild_id >> 22) % num_shards

# But for cache servers? Consistent hashing!
class DiscordCacheRouter:
    def __init__(self):
        self.ring = ConsistentHashRing(virtual_nodes=150)
    
    def get_cache_server(self, guild_id: str):
        return self.ring.get_server(f"guild:{guild_id}")</code></pre>
                <p class="fragment" style="font-size: 0.65em; margin-top: 10px;">
                    Guild messages, member lists, voice states ‚Üí <span style="color: var(--success);">all consistently hashed</span>
                </p>
            </section>

            <!-- SLIDE 16: Redis Cluster Slots -->
            <section>
                <h2>üî¥ Case Study: Redis Cluster</h2>
                <pre><code class="language-python"># Redis uses 16384 hash slots (not arbitrary ring)
# CRC16(key) % 16384 ‚Üí slot number

def key_to_slot(key: str) -> int:
    # Hash tags: {user}:profile and {user}:settings ‚Üí same slot
    if '{' in key:
        start = key.index('{') + 1
        end = key.index('}')
        key = key[start:end]
    return crc16(key.encode()) % 16384

# Slot distribution:
# Node A: slots 0-5460
# Node B: slots 5461-10922
# Node C: slots 10923-16383</code></pre>
                <div class="success-box" style="margin-top: 10px;">
                    <strong>Hash Tags</strong>: <code>{user123}:profile</code> and <code>{user123}:cart</code> ‚Üí same node!
                </div>
            </section>

            <!-- SLIDE 17: Replication Strategies -->
            <section>
                <h2>üîÑ Replication: Don't Lose Data</h2>
                <pre><code class="language-python">class ReplicatedHashRing:
    def get_nodes_for_key(self, key: str, replicas: int = 3):
        """Get primary + replica nodes for a key."""
        primary_hash = self._hash(key)
        nodes = []
        seen_physical = set()
        
        # Walk clockwise, skip virtual nodes of same physical server
        for node_hash in self._clockwise_from(primary_hash):
            physical_id = self.ring[node_hash].physical_id
            if physical_id not in seen_physical:
                nodes.append(self.ring[node_hash])
                seen_physical.add(physical_id)
            if len(nodes) >= replicas:
                break
        
        return nodes  # [Primary, Replica1, Replica2]</code></pre>
                <p class="fragment" style="font-size: 0.65em;">
                    Cassandra/DynamoDB: <strong>RF=3</strong> (3 copies across different nodes)
                </p>
            </section>

            <!-- SLIDE 18: Write Quorum -->
            <section>
                <h2>üìù Quorum Writes: How Many Must Succeed?</h2>
                <div class="two-column">
                    <div class="highlight-box">
                        <h3>Write Quorum</h3>
                        <p><code>W = (N/2) + 1</code></p>
                        <p>3 replicas ‚Üí W=2 must ACK</p>
                    </div>
                    <div class="highlight-box">
                        <h3>Read Quorum</h3>
                        <p><code>R = (N/2) + 1</code></p>
                        <p>3 replicas ‚Üí R=2 must respond</p>
                    </div>
                </div>
                <pre><code class="language-python">def write_with_quorum(self, key, value, W=2):
    nodes = self.get_nodes_for_key(key, replicas=3)
    acks = 0
    for node in nodes:
        if node.write(key, value):
            acks += 1
    return acks >= W  # True if quorum met</code></pre>
                <p class="fragment" style="font-size: 0.6em;">
                    <strong>Rule:</strong> W + R > N guarantees you read your own writes
                </p>
            </section>

            <!-- ==================== ACT 4: MULTI-TIER CACHING ==================== -->

            <!-- SLIDE 19: The Cache Hierarchy -->

            <!-- SLIDE 19: The Cache Hierarchy -->
            <section>
                <h2>Multi-Tier Cache Architecture</h2>
                <div class="pyramid">
                    <div class="pyramid-level">L1: RAM ‚Äî 100ns, 10GB (hot data)</div>
                    <div class="pyramid-level">L2: SSD ‚Äî 100¬µs, 1TB (warm data)</div>
                    <div class="pyramid-level">L3: Network ‚Äî 1ms, 100TB (cold data)</div>
                </div>
                <p style="font-size: 0.7em; margin-top: 25px; color: var(--secondary);">
                    Smaller & faster at top, larger & slower at bottom
                </p>
            </section>

            <!-- SLIDE 20: The Promotion Pattern -->
            <section>
                <h2>The Promotion Pattern</h2>
                <div class="pseudo-code">
<pre>GET "user:123":

1. Check L1 (RAM)     ‚Üí MISS
2. Check L2 (SSD)     ‚Üí MISS  
3. Check L3 (Network) ‚Üí HIT! üéØ
4. Promote to L2      ‚Üë
5. Promote to L1      ‚Üë
6. Return to user

Next request: L1 HIT (100ns!) ‚ö°</pre>
                </div>
                <p class="fragment" style="font-size: 0.7em; margin-top: 15px;">
                    Hot data <span class="gradient-text">bubbles up</span> through the tiers
                </p>
            </section>

            <!-- SLIDE 21: Multi-Tier Implementation -->
            <section>
                <h2>Multi-Tier Cache: Real Code</h2>
                <pre><code class="language-python">class MultiTierCache:
    def __init__(self):
        self.l1 = LRUCache(capacity=10_000)      # RAM: 10K items
        self.l2 = SSDCache(max_size_gb=100)      # SSD: 100GB
        self.l3 = DistributedCache(servers=10)   # Network cluster
    
    def get(self, key: str):
        # L1: Check RAM (100ns)
        if value := self.l1.get(key):
            return value
        
        # L2: Check SSD (100¬µs) ‚Üí promote to L1
        if value := self.l2.get(key):
            self.l1.put(key, value)
            return value
        
        # L3: Check cluster (1ms) ‚Üí promote to L1 & L2
        if value := self.l3.get(key):
            self.l2.put(key, value)
            self.l1.put(key, value)
            return value
        
        return None  # Cache miss ‚Üí hit database</code></pre>
            </section>

            <!-- SLIDE 22: This Pattern Is Everywhere -->
            <section>
                <h2>This Pattern Is Everywhere</h2>
                <table>
                    <tr>
                        <th>System</th>
                        <th>L1</th>
                        <th>L2</th>
                        <th>L3</th>
                    </tr>
                    <tr>
                        <td><strong>CPU</strong></td>
                        <td>L1 cache (1ns)</td>
                        <td>L2 cache (4ns)</td>
                        <td>L3/RAM (100ns)</td>
                    </tr>
                    <tr>
                        <td><strong>CDN</strong></td>
                        <td>Edge PoP</td>
                        <td>Regional</td>
                        <td>Origin</td>
                    </tr>
                    <tr>
                        <td><strong>Facebook TAO</strong></td>
                        <td>Memcache</td>
                        <td>TAO Leaders</td>
                        <td>MySQL</td>
                    </tr>
                    <tr>
                        <td><strong>Netflix</strong></td>
                        <td>EVCache</td>
                        <td>Regional SSD</td>
                        <td>S3/Cassandra</td>
                    </tr>
                </table>
            </section>

            <!-- ==================== ACT 5: CDN & EDGE ==================== -->

            <!-- SLIDE 23: CDN Edge Architecture -->
            <section>
                <h2>üåç CDN: Caching at Planetary Scale</h2>
                <pre><code class="language-python">class CDNEdgeNode:
    """One of 300+ edge locations worldwide."""
    
    def __init__(self, location: str, capacity_tb: int):
        self.location = location  # "sjc", "ams", "nrt"
        self.cache = LRUCache(capacity_tb * 1_000_000)
        self.origin = "https://origin.example.com"
    
    def get_asset(self, path: str, headers: dict):
        cache_key = self._cache_key(path, headers)
        
        if cached := self.cache.get(cache_key):
            return Response(cached, headers={"X-Cache": "HIT"})
        
        # Cache miss ‚Üí fetch from origin
        response = self._fetch_origin(path)
        if self._is_cacheable(response):
            ttl = self._parse_cache_control(response.headers)
            self.cache.put(cache_key, response.body, ttl=ttl)
        
        return Response(response.body, headers={"X-Cache": "MISS"})</code></pre>
            </section>

            <!-- SLIDE 24: Geo Routing -->
            <section>
                <h2>üó∫Ô∏è DNS-Based Geo Routing</h2>
                <pre><code class="language-python">class GeoDNS:
    """Route users to nearest edge location."""
    
    edge_locations = {
        "us-west": ["sjc", "lax", "sea"],
        "us-east": ["iad", "ewr", "atl"],
        "europe":  ["ams", "fra", "lhr"],
        "asia":    ["nrt", "sin", "hkg"],
    }
    
    def resolve(self, domain: str, client_ip: str) -> str:
        region = self.geoip_lookup(client_ip)
        edges = self.edge_locations.get(region, ["iad"])
        
        # Return healthiest, least-loaded edge
        return self.select_best_edge(edges)
    
# User in Tokyo ‚Üí nrt.cdn.example.com (5ms)
# User in London ‚Üí lhr.cdn.example.com (8ms)
# vs Origin in Virginia ‚Üí 180ms!</code></pre>
            </section>

            <!-- SLIDE 25: Thundering Herd Problem -->
            <section>
                <h2>‚ö° The Thundering Herd Problem</h2>
                <div class="disaster-box">
                    <p><strong>Scenario:</strong> Popular cache key expires</p>
                    <p>‚Üí 10,000 requests hit simultaneously</p>
                    <p>‚Üí ALL miss cache, ALL query database</p>
                    <p>‚Üí <span class="disaster-text">Database collapses</span></p>
                </div>
                <pre><code class="language-python"># SOLUTION: Request coalescing (single-flight)
class CoalescingCache:
    def __init__(self):
        self.cache = {}
        self.in_flight = {}  # key ‚Üí Future
    
    async def get(self, key: str):
        if key in self.cache:
            return self.cache[key]
        
        if key in self.in_flight:
            return await self.in_flight[key]  # Wait for first request
        
        # First request: fetch and share result
        self.in_flight[key] = asyncio.create_task(self._fetch(key))
        result = await self.in_flight[key]
        del self.in_flight[key]
        return result</code></pre>
            </section>

            <!-- SLIDE 26: Hot Key Solutions -->
            <section>
                <h2>üî• Hot Keys: When One Key Gets ALL Traffic</h2>
                <div class="warning-box">
                    <p><strong>Problem:</strong> Celebrity tweet, viral product, breaking news</p>
                    <p>One key ‚Üí millions of requests ‚Üí one server overwhelmed</p>
                </div>
                <pre><code class="language-python"># Solution 1: Local caching + short TTL
if key in local_cache:  # Each app server caches locally
    return local_cache[key]

# Solution 2: Key splitting
def get_hot_key(key: str):
    # Spread across 10 cache copies
    shard = random.randint(0, 9)
    return cache.get(f"{key}:shard:{shard}")

# Solution 3: Read replicas
# Writes ‚Üí primary, Reads ‚Üí any replica</code></pre>
                <p class="fragment" style="font-size: 0.6em;">
                    Twitter uses <strong>all three</strong> for trending topics
                </p>
            </section>

            <!-- ==================== ACT 6: THE HARDEST PROBLEM ==================== -->

            <!-- ==================== ACT 6: THE HARDEST PROBLEM ==================== -->

            <!-- SLIDE 27: Cache Invalidation -->
            <section>
                <h2>The Hardest Problem</h2>
                <blockquote>
                    "There are only two hard things in Computer Science: cache invalidation and naming things."
                    <br><br>
                    <span style="font-size: 0.8em;">‚Äî Phil Karlton</span>
                </blockquote>
                <p class="fragment" style="font-size: 0.75em; margin-top: 25px;">
                    When data changes, how do you update the cache?
                </p>
            </section>

            <!-- SLIDE 28: Invalidation Strategies Deep Dive -->
            <section>
                <h2>Invalidation Strategies: Deep Dive</h2>
                <pre><code class="language-python"># 1. TTL (Time-To-Live) ‚Äî Simple but stale
cache.set("user:123", data, ttl=300)  # Expires in 5 min

# 2. Write-Through ‚Äî Consistent but slow
def update_user(user_id, data):
    db.update(user_id, data)
    cache.set(f"user:{user_id}", data)  # Sync update

# 3. Write-Behind (Async) ‚Äî Fast but risky
def update_user(user_id, data):
    cache.set(f"user:{user_id}", data)  # Update cache first
    queue.push({"op": "update", "user_id": user_id, "data": data})
    # Worker writes to DB async

# 4. Cache-Aside (Lazy) ‚Äî Most common
def get_user(user_id):
    if cached := cache.get(f"user:{user_id}"):
        return cached
    data = db.get(user_id)
    cache.set(f"user:{user_id}", data, ttl=300)
    return data</code></pre>
            </section>

            <!-- SLIDE 29: Consistency vs Availability -->
            <section>
                <h2>The Consistency Spectrum</h2>
                <table>
                    <tr>
                        <th>Level</th>
                        <th>Guarantee</th>
                        <th>Use Case</th>
                    </tr>
                    <tr>
                        <td><strong>Strong</strong></td>
                        <td>Read always sees latest write</td>
                        <td>Banking, inventory</td>
                    </tr>
                    <tr>
                        <td><strong>Eventual</strong></td>
                        <td>Eventually converges</td>
                        <td>Social media, analytics</td>
                    </tr>
                    <tr>
                        <td><strong>Read-Your-Writes</strong></td>
                        <td>You see your own updates</td>
                        <td>User profiles, settings</td>
                    </tr>
                </table>
                <div class="insight-box" style="margin-top: 15px;">
                    <p><strong>CAP Theorem:</strong> Pick 2 of 3 ‚Äî Consistency, Availability, Partition tolerance</p>
                    <p>Caches usually pick <strong>AP</strong> (available + partition tolerant, eventually consistent)</p>
                </div>
            </section>

            <!-- ==================== FINALE ==================== -->

            <!-- SLIDE 30: Season 1 Journey Complete -->
            <section>
                <h2>Season 1 Journey Complete</h2>
                <div class="episode-list">
                    <p>Ep 1: Singly Linked List ‚Üí <span style="color: var(--primary);">Git Commits</span></p>
                    <p>Ep 2: List Intersection ‚Üí <span style="color: var(--primary);">Git Merge-Base</span></p>
                    <p>Ep 3: Doubly Linked List ‚Üí <span style="color: var(--primary);">Browser History</span></p>
                    <p>Ep 4: Immutable Lists ‚Üí <span style="color: var(--primary);">Time Travel Debugging</span></p>
                    <p>Ep 5: LRU Cache ‚Üí <span style="color: var(--primary);">Browser & DB Caching</span></p>
                    <p class="current">Ep 6: Consistent Hashing ‚Üí <span style="color: var(--secondary);">Global CDNs</span> ‚Üê <span style="color: var(--secondary);">Circular linked structure!</span></p>
                </div>
            </section>

            <!-- SLIDE 31: The Invisible Linked List -->
            <section>
                <h1>The Invisible Linked List</h1>
                <blockquote style="margin-top: 30px;">
                    "From a single <code>node.next</code> pointer to a global network serving billions.<br><br>
                    The linked list isn't just an interview question‚Äî<br>
                    it's the <span class="gradient-text">invisible foundation</span> of every system you use."
                </blockquote>
                <p style="font-size: 0.7em; margin-top: 30px; color: var(--secondary);">
                    üå≥ Season 2: Trees, Graphs, and Search Engines
                </p>
            </section>

        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.5.0/reveal.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.5.0/plugin/highlight/highlight.min.js"></script>
    <script>
        Reveal.initialize({
            hash: true,
            slideNumber: 'c/t',
            transition: 'slide',
            transitionSpeed: 'default',
            backgroundTransition: 'fade',
            plugins: [RevealHighlight],
            width: 1200,
            height: 700,
            margin: 0.1
        });
    </script>
</body>
</html>
